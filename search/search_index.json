{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"bgpipe: BGP reverse proxy","text":"<p>bgpipe is an open-source tool for processing and filtering messages exchanged by the Border Gateway Protocol (BGP). BGP is the routing protocol that makes the Internet work, and as such it is considered to be critical to the global economic prosperity and security.</p> <p>bgpipe operates as a proxy sitting between two BGP routers, capable of auditing, fixing, and securing BGP sessions on the fly. It is based on the BGPFix library, distributed under the MIT license, and implemented in Go, making it widely available for many platforms.</p> <p>Started in 2023, bgpipe has its roots in a research project developed at the Institute of Theoretical and Applied Informatics, Polish Academy of Sciences.</p> <ul> <li> <p> What is bgpipe?</p> <p>Understand the basics  Introduction</p> </li> <li> <p> Quick Start</p> <p>Get started in minutes  Quick Start</p> </li> <li> <p> Downloads</p> <p>Download and install bgpipe  GitHub Releases</p> </li> <li> <p> Motivation</p> <p>Read background paper  Kirin Attack</p> </li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Works as a transparent man-in-the-middle proxy.</li> <li>Has full, bi-directional BGP to JSON translation (with Flowspec).</li> <li>Can filter and archive BGP sessions through an external process, eg. a Python script.</li> <li>Supports remote processing over encrypted WebSockets (HTTPS), eg. in the cloud.</li> <li>Reads and writes MRT files (BGP4MP), optionally compressed.</li> <li>Compatible with ExaBGP's line-based text format for easy integration.</li> <li>Can add and drop TCP-MD5 on multi-hop BGP sessions, independently on each side.</li> <li>Has built-in BGP message filters and session limiters.</li> <li>Supports popular BGP RFCs, including Flowspec.</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Below are practical examples to help you get started with  <code>bgpipe</code>  after you went through the quickstart guide. These examples demonstrate how to use  <code>bgpipe</code>  for various BGP-related tasks, such as connecting to BGP speakers, reading MRT files, filtering messages, and more.</p>"},{"location":"examples/#connect-to-a-bgp-speaker","title":"Connect to a BGP speaker","text":"<p>Connect to a BGP speaker and respond to OPEN message using the same ASN. Note that if an IP address is used as a stage, it is a shorthand for <code>connect &lt;ip&gt;</code>. The command dumps the session in JSON format to stdout, since the <code>-o</code> option is enabled. It's useful for debugging and monitoring BGP sessions, allowing you to see the raw BGP messages.</p> <pre><code>bgpipe -o speaker -- 1.2.3.4\n</code></pre>"},{"location":"examples/#json-to-bgp-and-back","title":"JSON to BGP and back","text":"<p>Convert a JSON input file to BGP messages, send them to a BGP speaker, and capture the output back in JSON format. This example is useful for testing BGP message processing in remote speakers.</p> <pre><code>cat input.json \\\n  | bgpipe -io speaker -- 1.2.3.4 \\\n  | tee output.json\n</code></pre>"},{"location":"examples/#convert-mrt-files-to-json","title":"Convert MRT files to JSON","text":"<p>Read MRT updates from a compressed file and convert the updates to JSON format. This is particularly useful for analyzing historical BGP data stored in MRT files, which are often used for archiving BGP updates.</p> <pre><code>bgpipe \\\n  -- read updates.20230301.0000.bz2 \\\n  -- write output.json\n</code></pre>"},{"location":"examples/#adding-tcp-md5","title":"Adding TCP-MD5","text":"<p>Set up a proxy that listens on TCP port 179, waits for a connection, and then proxies it to <code>1.2.3.4</code> with a popular TCP-MD5 password. The conversation is printed to stdout. This setup is useful for \"securing\" BGP sessions, ensuring that only authorized peers can establish a TCP connection. It supports multi-hop scenarios.</p> <pre><code>bgpipe -o \\\n  -- listen :179 \\\n  -- connect --wait listen --md5 solarwinds123 1.2.3.4\n</code></pre>"},{"location":"examples/#stream-mrt-files-to-bgp-routers","title":"Stream MRT files to BGP routers","text":"<p>Listen for new connections on TCP port 179. Configure an active BGP speaker for <code>AS65055</code> that streams a given MRT file when the BGP session is established. This example demonstrates how to replay historical BGP data in a live BGP session, which can be useful for testing and analysis.</p> <pre><code>bgpipe \\\n  -- speaker --active --asn 65055 \\\n  -- read --wait ESTABLISHED updates.20230301.0000.bz2 \\\n  -- listen :179\n</code></pre>"},{"location":"examples/#bgp-sed-in-the-middle-proxy","title":"BGP sed-in-the-middle proxy","text":"<p>Create a BGP proxy that connects <code>1.2.3.4</code> with 85.232.240.179, but rewrites ASNs in their OPEN messages using sed. This is useful for quickly testing and modifying BGP sessions on the fly, allowing you to simulate different network scenarios.</p> <pre><code>bgpipe \\\n  -- connect 1.2.3.4 \\\n  -- exec -LR --args sed -ure '/\"OPEN\"/{ s/65055/65001/g; s/57355/65055/g }' \\\n  -- connect 85.232.240.179\n</code></pre>"},{"location":"examples/#applying-prefix-limits","title":"Applying prefix limits","text":"<p>Filter BGP updates based on prefix lengths and enforce maximum prefix session limits for both IPv4 and IPv6 connections. This helps in managing and securing BGP sessions by limiting the number of prefixes, which can prevent resource exhaustion.</p> <pre><code>bgpipe --kill limit/session \\\n  -- connect 1.2.3.4 \\\n  -- limit -LR --ipv4 --min-length  8 --max-length 24 --session 1000000 \\\n  -- limit -LR --ipv6 --min-length 16 --max-length 48 --session 250000 \\\n  -- connect 5.6.7.8\n</code></pre>"},{"location":"examples/#archive-bgp-sessions-over-encrypted-websockets","title":"Archive BGP sessions over encrypted WebSockets","text":"<p>Stream the BGP session log in JSON format to a remote WebSocket server for real-time monitoring and archiving. This is useful for integrating BGP session data with external monitoring systems, providing a live feed of BGP activity.</p> <pre><code>bgpipe \\\n  -- connect 1.2.3.4 \\\n  -- websocket -LR --write wss://bgpfix.com/archive?user=demo \\\n  -- connect 85.232.240.179\n</code></pre>"},{"location":"examples/#grep-for-bgp-messages-in-live-sessions","title":"Grep for BGP messages in live sessions","text":"<p>Proxy a connection between two BGP peers, allowing only IPv6 updates from origin AS <code>12345</code>. This is useful for environments that wish to only accept IPv6 prefixes from a specific ASN. The <code>grep</code> stage allows for complex filtering based on various criteria such as message type, prefix, AS_PATH, and more.</p> <pre><code>bgpipe \\\n  -- connect 1.2.3.4 \\\n  -- grep 'ipv6 &amp;&amp; as_origin = 12345' \\\n  -- connect 85.232.240.179\n</code></pre>"},{"location":"examples/#monitor-bgp-prefixes-in-real-time","title":"Monitor BGP prefixes in real-time","text":"<p>Connect to RIPE RIS Live to stream real-time BGP updates from many route collectors, and filter for a specific prefix you're monitoring. RIS Live provides a view of the global BGP routing table without needing your own BGP connections - perfect for network security monitoring, research, and troubleshooting.</p> <pre><code># Monitor all announcements for your network prefix\nbgpipe -g \\\n  -- ris-live \\\n  -- grep 'prefix ~ 1.1.1.0/24' \\\n  -- stdout\n</code></pre>"},{"location":"examples/#stream-live-bgp-with-rpki-filtering","title":"Stream live BGP with RPKI filtering","text":"<p>Stream RIS Live UPDATEs and validate them against RPKI to detect and filter invalid route announcements in real-time. This combines global visibility with cryptographic validation to protect against BGP hijacking and route leaks. The updates will not be modified on the BGP level (<code>--invalid=keep</code> flag), but will be tagged with <code>rpki/status = INVALID</code>. The <code>update</code> stage is then used to add a community <code>123:456</code> to invalid updates for easy identification. Finally, the stream is saved to a file in JSON format.</p> <pre><code># Real-time BGP monitoring with RPKI validation\nbgpipe -g \\\n  -- ris-live \\\n  -- rpki --invalid=keep \\\n  -- update --if 'tag[rpki/status] = INVALID' --add-com 123:456 \\\n  -- write ris-rpki-updates.json\n</code></pre>"},{"location":"examples/#secure-your-bgp-sessions-with-rpki","title":"Secure your BGP sessions with RPKI","text":"<p>Add RPKI validation to a BGP proxy between two routers. Invalid prefixes are automatically moved to the withdrawn list (following RFC 7606), preventing propagation of unauthorized route announcements. RPKI uses cryptographic signatures to verify that an AS is authorized to originate a prefix - this protects against both malicious hijacks and configuration errors. The validator connects to Cloudflare's public RTR server by default (or you can use <code>--file</code> to load a local ROA cache).</p> <pre><code># Secure 5.6.7.8 by filtering RPKI-invalid prefixes coming from 1.2.3.4\nbgpipe \\\n  -- listen 1.2.3.4 \\\n  -- rpki \\\n  -- connect 5.6.7.8\n</code></pre>"},{"location":"examples/#strict-rpki-enforcement-mode","title":"Strict RPKI enforcement mode","text":"<p>Enable strict mode to treat prefixes without any RPKI ROA the same as invalid prefixes. This aggressive stance only allows messages from <code>1.2.3.4</code> clients forwarded to <code>5.6.7.8</code> where all announced prefixes have explicit RPKI authorization, dropping and logging any violations.</p> <pre><code># Drop messages announcing INVALID and/or NOT_FOUND prefixes\nbgpipe --events rpki/dropped \\\n  -- listen 1.2.3.4 \\\n  -- rpki --strict --invalid=drop --event dropped \\\n  -- connect 5.6.7.8\n</code></pre>"},{"location":"examples/#rate-limiting-and-sampling-bgp-streams","title":"Rate limiting and sampling BGP streams","text":"<p>Protect downstream systems from BGP update storms by rate limiting message flow, or sample high-volume feeds for statistical analysis. The <code>--rate-limit</code> flag delays messages to maintain a maximum rate (messages per second), while <code>--rate-sample</code> randomly samples messages when over the rate threshold, discarding excess messages. This is particularly useful when processing RIS Live feeds or during BGP convergence events.</p> <pre><code># Sample RIS Live at max 100 updates/sec to avoid overwhelming storage\nbgpipe -g \\\n  -- ris-live --rate-sample 100 \\\n  -- write sampled-updates.json\n\n# Rate limit updates from 5.6.7.8 to 50 msg/sec (smooths bursts)\nbgpipe \\\n  -- listen 1.2.3.4 \\\n  -- connect --rate-limit 50 5.6.7.8\n</code></pre>"},{"location":"examples/#exabgp-compatibility","title":"ExaBGP compatibility","text":"<p>Use the <code>--format=exa</code> flag to read and write ExaBGP line format instead of JSON. This allows integration with existing ExaBGP-based scripts and tools.</p> <pre><code># Process BGP messages with an ExaBGP-compatible script\nbgpipe \\\n  -- listen 1.2.3.4 \\\n  -- exec --format=exa -LR --args /path/to/script.py \\\n  -- connect 5.6.7.8\n\n# Convert JSON to ExaBGP format\ncat session.json | bgpipe stdin -- stdout --format=exa\n</code></pre>"},{"location":"filters/","title":"Message Filters","text":""},{"location":"filters/#overview","title":"Overview","text":"<p>This page explains how to write BGP message filters, used eg. in the <code>grep</code> and <code>drop</code> stages in <code>bgpipe</code>. Filters let you keep (<code>grep</code>) or remove (<code>drop</code>) BGP messages based on message type, NLRI/prefixes, next-hop, AS path, communities, tags, and more.</p> <p>Summary:</p> <ul> <li>Use <code>grep &lt;FILTER&gt;</code> to keep only the messages that match FILTER</li> <li>Use <code>drop &lt;FILTER&gt;</code> to remove the messages that match FILTER</li> <li>Use <code>&lt;stage&gt; --if &lt;CONDITION&gt;</code> to skip a stage completely if the message does not match CONDITION first (<code>--if</code> here corresponds to stage input filter)</li> <li>Combine multiple expressions with <code>&amp;&amp;</code> (AND) and <code>||</code> (OR)</li> <li>Use <code>(...)</code> to group and <code>!</code> to negate expressions</li> </ul> <p>Examples:</p> <pre><code># keep only IPv6 updates from AS65000\nbgpipe -o read updates.mrt.gz \\\n  -- grep 'ipv6 &amp;&amp; as_origin == 65000'\n\n# drop non-IPv6 updates from AS_PATHs that end with ASN matching 204[0-9]+\nbgpipe -o read updates.mrt.gz \\\n  -- drop '!ipv6 &amp;&amp; as_path ~ ,204[0-9]+$'\n\n# only for UPDATEs originated by AS15169, drop if no prefixes match 8.0.0.0/8\nbgpipe -o read updates.mrt.gz \\\n  -- grep --if 'as_origin == 15169' 'prefix ~ 8.0.0.0/8'\n</code></pre>"},{"location":"filters/#filter-syntax","title":"Filter Syntax","text":"<p>A filter is made of one or more expressions:</p> <ul> <li>Expression - one of:<ul> <li><code>attribute</code> or <code>attribute[index]</code></li> <li><code>attribute operator value</code> or <code>attribute[index] operator value</code></li> </ul> </li> <li>Chain expressions with <code>&amp;&amp;</code> (AND) and <code>||</code> (OR)</li> <li>Group with <code>( ... )</code></li> <li>Negate with <code>!</code></li> </ul> <p>Where:</p> <ul> <li><code>attribute</code>: which message attribute you want to test, eg. <code>prefix</code>, <code>aspath</code>, etc.</li> <li><code>[index]</code>: an optional selector within that attribute (e.g., <code>aspath[1]</code>, <code>tag[env]</code>)</li> <li><code>operator</code>: value comparison operator (see below)</li> <li><code>value</code>: value to compare against (strings can be double-quoted with <code>\"...\"</code>)</li> </ul> <p>Supported operators:</p> <ul> <li><code>==</code> or <code>=</code>: equality</li> <li><code>!=</code>: inequality (implemented as negated equality)</li> <li><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>: numeric comparisons (where applicable)</li> <li><code>~</code>: match (attribute-specific, e.g., prefix overlap, membership)</li> <li><code>!~</code>: negative match (negated membership)</li> </ul> <p>Values:</p> <ul> <li>Unquoted tokens, or quoted strings <code>\"...\"</code> (supports <code>\\\\</code> escaping)</li> <li>Numbers are parsed as integers or floats (0x... supported for ints)</li> </ul> <p>Important: Most attributes apply to UPDATE messages only. If your filter uses UPDATE-only attributes (e.g., prefix/aspath/communities) and the message is not an UPDATE (e.g., OPEN/KEEPALIVE), that expression evaluates to false. Use <code>type</code> conditions if you want to match non-UPDATE messages.</p>"},{"location":"filters/#attributes","title":"Attributes","text":"<p>Below are the attributes you can use. Some keywords are shortcuts that expand to comparisons on <code>type</code> or <code>af</code>.</p>"},{"location":"filters/#message-type","title":"Message type","text":"<ul> <li><code>type</code>: explicit type comparison</li> <li>Shortcuts: <code>update</code>, <code>open</code>, <code>keepalive</code></li> </ul> <p>Examples:</p> <pre><code>update                     # same as: type == UPDATE\nopen || keepalive          # match session control messages\n!update || type == OPEN    # only OPEN, not UPDATE\n</code></pre>"},{"location":"filters/#address-family","title":"Address family","text":"<ul> <li><code>af</code>: address family (AFI/SAFI)</li> <li>Shortcuts: <code>ipv4</code> (<code>af == IPV4/UNICAST</code>), <code>ipv6</code> (<code>af == IPV6/UNICAST</code>)</li> </ul> <p>Examples:</p> <pre><code>ipv4 &amp;&amp; update\nipv6 &amp;&amp; prefix ~ 2001:db8::/32\n</code></pre>"},{"location":"filters/#nlri-prefixes","title":"NLRI / prefixes","text":"<ul> <li><code>reach</code>: prefixes in MP_REACH or classic IPv4 reachability</li> <li><code>unreach</code>: prefixes in MP_UNREACH or classic IPv4 withdrawals</li> <li><code>prefix</code>: union of <code>reach</code> and <code>unreach</code></li> </ul> <p>Operators:</p> <ul> <li><code>==</code> exact match, e.g. <code>prefix == 203.0.113.0/24</code></li> <li><code>~</code> overlap (subnet) test, e.g. <code>prefix ~ 203.0.113.0/24</code></li> </ul> <p>Examples:</p> <pre><code>prefix ~ 8.0.0.0/8            # any prefix overlapping 8/8\nreach == 203.0.113.0/24       # exact announcement of 203.0.113.0/24\nunreach ~ 2001:db8::/32       # any withdrawal inside 2001:db8::/32\n</code></pre>"},{"location":"filters/#next-hop","title":"Next-hop","text":"<ul> <li><code>nexthop</code> or <code>nh</code>: match next-hop IP</li> </ul> <p>Examples:</p> <pre><code>nh == 192.0.2.1\nnexthop ~ 2001:db8::/64\n</code></pre>"},{"location":"filters/#as-path","title":"AS path","text":"<ul> <li><code>aspath</code> matches full AS_PATH</li> <li><code>aspath[index]</code> matches particular index</li> <li>Shortcuts:<ul> <li><code>as_origin</code> is origin AS (rightmost, index -1)</li> <li><code>as_upstream</code> is upstream of origin (index -2)</li> <li><code>as_peer</code> is neighbor/peer AS (leftmost, index 0)</li> </ul> </li> </ul> <p>Indexing rules:</p> <ul> <li>Numeric indexes pick a specific position: <code>aspath[0]</code> is the leftmost AS (peer).</li> <li>Negative indexes count from the right: <code>aspath[-1]</code> is the origin; <code>aspath[-2]</code> upstream of origin.</li> <li>If you omit the index on the shortcuts, they assume the position above (e.g., <code>as_origin</code> implies <code>[-1]</code>).</li> </ul> <p>Examples:</p> <pre><code>as_origin == 64496\nas_peer != 64512\naspath[1] == 3356\naspath[-2] == 3356\n</code></pre>"},{"location":"filters/#communities","title":"Communities","text":"<ul> <li><code>community</code> or <code>com</code>: standard communities</li> <li><code>com_ext</code>, <code>ext_community</code>, <code>ext_com</code>: extended communities</li> <li><code>com_large</code>, <code>large_community</code>, <code>large_com</code>: large communities</li> </ul> <p>Operators and values:</p> <ul> <li>Use <code>==</code> for exact string match</li> <li>Use <code>~</code> to match against a regular expression</li> <li>Community formats are strings like <code>\"65000:1\"</code> or <code>\"1234:5678:90\"</code></li> </ul> <p>Examples:</p> <pre><code>community ~ \"3356:\"\ncom_large ~ \"1234:5678:9\"\next_community ~ \"rt:65000:1\"\n</code></pre>"},{"location":"filters/#tags-pipeline-context","title":"Tags (pipeline context)","text":"<p>Tags are key/value pairs attached to messages by the <code>tag</code> stage. You can match them with the <code>tag[...]</code> attribute.</p> <p>Indexing rules for tags:</p> <ul> <li>the index is a string key, e.g., <code>tag[env]</code>, <code>tags[region]</code></li> <li><code>==</code> compares the exact tag value</li> <li><code>~</code> can be used for pattern-like matches</li> </ul> <p>Examples:</p> <pre><code>tag[env] == prod\ntags[region] ~ \"^eu-\"\n</code></pre>"},{"location":"intro/","title":"Introduction","text":"<p><code>bgpipe</code> is a unique open-source tool that combines BGP monitoring with active message manipulation capabilities. While traditional BGP tools are often limited to passive observation, <code>bgpipe</code> operates as a transparent proxy between BGP speakers, allowing real-time inspection and modification of BGP messages.</p> <p><code>bgpipe</code> processes BGP messages through a series of stages, where each stage performs specific actions such as message filtering, format conversion, or security enhancement. For example, you can:</p> <ul> <li>Convert BGP messages to JSON and back for easy processing</li> <li>Add TCP-MD5 authentication to existing BGP sessions</li> <li>Filter BGP updates based on prefix lengths or AS paths</li> <li>Apply rate limits and prefix thresholds to prevent flooding attacks</li> <li>Archive BGP sessions to MRT files or remote WebSocket servers</li> <li>Process messages through external programs like Python scripts</li> </ul> <p>See the quickstart guide for a practical introduction to bgpipe. You can also watch the below RIPE88 bgpipe talk.</p> <p>The talk was summarized in June 2024 by Geoff Huston on the APNIC blog as follows:</p> <p>Observing and measuring the dynamic behaviour of BGP has used a small set of tools for quite some time. There\u2019s the BGP Monitoring Protocol (BMP, RFC 7854), there\u2019s the Multi-threaded Routing Toolkit (MRT) for BGP snapshot and update logs, and if you really want to head back to the earliest days of this work, there are scripts to interrogate a router via the command-line interface, CLI. All of these are observation tools, but they cannot alter the BGP messages that are being passed between BGP speakers.</p> <p>The bgpipe tool, presented by Pawe\u0142 Foremski, is an interesting tool that operates both as a BGP \u2018wire sniffer\u2019 but also allows BGP messages to be altered on the fly (Figure 1).</p> <p></p> <p>Internally, the bgpipe process can be configured to invoke supplied \u2018callback\u2019 routines when part of a BGP message matches some provided pattern, such as a particular IP prefix, update attribute patterns or such, and it can also be configured to have \u2018events\u2019 which processing elements in bgpipe can subscribe to. Simple use cases are to take a BGP session and produce a JSON-formatted log of all BGP messages or take an unencrypted BGP session and add TCP-MD5 encryption. More advanced cases can make use of an external call interface to add route validation checks using RPKI credentials.</p> <p>There has been some concern about using IPv6 prefixes to perform a BGP more specific route flooding attack and its possible to use a bgpipe module to perform various forms of prefix thresholds (per origin Autonomous System (AS) or per aggregate prefix) to detect and filter out the effects of such flooding attacks.</p> <p>It\u2019s early days in this work, but it is certainly an intriguing and novel BGP tool.</p>"},{"location":"json-format/","title":"JSON Message Format","text":"<p>bgpipe can represent BGP messages in a structured JSON format for easy processing and filtering. This page documents the format, which is implemented by the bgpfix library. For example, the JSON translation feature can be useful for external processors - e.g. Python scripts via the <code>exec</code> or <code>websocket</code> stages - or for BGP message inspection or archiving.</p>"},{"location":"json-format/#overview","title":"Overview","text":"<p>Each BGP message is represented as a JSON array with the following structure:</p> <pre><code>[dir, seq, time, type, data, meta]\n</code></pre> <p>Where:</p> Index Name Type Description <code>[0]</code> <code>dir</code> string direction: <code>L</code> (left) or <code>R</code> (right) <code>[1]</code> <code>seq</code> int sequence number (monotonic counter) <code>[2]</code> <code>time</code> string timestamp in <code>YYYY-MM-DDTHH:MM:SS.mmm</code> format <code>[3]</code> <code>type</code> string/int type: <code>OPEN</code>, <code>UPDATE</code>, <code>KEEPALIVE</code>, etc. <code>[4]</code> <code>data</code> object/string type-specific object or raw hex string (optional) <code>[5]</code> <code>meta</code> object bgpipe metadata (optional) <p>Example KEEPALIVE Message</p> <pre><code>[\"R\", 2, \"2025-07-11T08:47:22.659\", \"KEEPALIVE\"]\n</code></pre>"},{"location":"json-format/#open-messages","title":"OPEN Messages","text":"<p>For OPEN messages, the <code>data</code> field contains a JSON object with the BGP session parameters and capabilities:</p> <pre><code>{\n  \"bgp\": 4,\n  \"asn\": 65055,\n  \"id\": \"192.0.2.1\",\n  \"hold\": 90,\n  \"caps\": { ... } // or \"params\": \"0x...\" if no caps\n}\n</code></pre> <p>Where:</p> Field Type Description <code>bgp</code> int BGP protocol version (always 4) <code>asn</code> int Autonomous System Number (2-byte) <code>id</code> string BGP Router ID in dotted-decimal IPv4 format <code>hold</code> int Hold time in seconds <code>caps</code> object BGP capabilities (see below) <code>params</code> string Raw optional parameters as hex string (only if no caps) <p>The <code>caps</code> object contains BGP capabilities:</p> <pre><code>{\n  \"MP\": [\"IPV4/UNICAST\"],\n  \"ROUTE_REFRESH\": true,\n  \"EXTENDED_MESSAGE\": true,\n  \"AS4\": 64515\n}\n</code></pre> <p>Common capabilities (see bgpfix source):</p> <ul> <li><code>MP</code>: Array of supported AFI/SAFI combinations (e.g., <code>IPV4/UNICAST</code>, <code>IPV6/FLOWSPEC</code>)</li> <li><code>ROUTE_REFRESH</code>: Boolean, supports Route Refresh (RFC 2918)</li> <li><code>EXTENDED_MESSAGE</code>: Boolean, supports messages larger than 4096 bytes (RFC 8654)</li> <li><code>AS4</code>: Number, 4-byte ASN value (RFC 6793)</li> </ul> <p>Complete example:</p> <pre><code>[\n  \"L\",\n  1,\n  \"2025-07-11T08:47:22.659\",\n  \"OPEN\",\n  {\n    \"bgp\": 4,\n    \"asn\": 65055,\n    \"id\": \"85.232.240.180\",\n    \"hold\": 7200,\n    \"caps\": {\n      \"MP\": [\"IPV4/FLOWSPEC\"],\n      \"ROUTE_REFRESH\": true\n    }\n  }\n]\n</code></pre>"},{"location":"json-format/#update-messages","title":"UPDATE Messages","text":"<p>For UPDATE messages, element <code>data</code> field contains a JSON object with reachable/withdrawn IPv4 prefixes and the path attributes:</p> <pre><code>{\n  \"reach\": [ ... ],\n  \"unreach\": [ ... ],\n  \"attrs\": { ... }\n}\n</code></pre> <p>Where:</p> Field Type Description <code>reach</code> array Array of reachable IPv4 unicast prefixes (announced routes) <code>unreach</code> array Array of unreachable IPv4 unicast prefixes (withdrawn routes) <code>attrs</code> object BGP path attributes (see below) <p>Note: For MP-BGP (multi-protocol) routes (IPv6, Flowspec, etc.), prefixes are embedded within the <code>MP_REACH</code> or <code>MP_UNREACH</code> attributes.</p>"},{"location":"json-format/#path-attributes","title":"Path Attributes","text":"<p>The <code>attrs</code> object contains BGP path attributes. Each attribute has:</p> <ul> <li>Key: Attribute name (e.g., <code>ORIGIN</code>, <code>ASPATH</code>, <code>COMMUNITY</code>)</li> <li>Value: Object with <code>flags</code> and <code>value</code> fields</li> </ul> <pre><code>\"ORIGIN\": {\n  \"flags\": \"T\",\n  \"value\": \"IGP\"\n}\n</code></pre>"},{"location":"json-format/#attribute-flags","title":"Attribute Flags","text":"<p>Flags are a string combining these characters:</p> <ul> <li><code>O</code>: Optional</li> <li><code>T</code>: Transitive</li> <li><code>P</code>: Partial</li> <li><code>X</code>: Extended length</li> </ul> <p>Well-known attributes (ORIGIN, ASPATH, NEXTHOP) use <code>T</code> only. Optional attributes use combinations like <code>OT</code>.</p>"},{"location":"json-format/#common-path-attributes","title":"Common Path Attributes","text":""},{"location":"json-format/#origin","title":"ORIGIN","text":"<p>Origin of the route:</p> <pre><code>\"ORIGIN\": {\n  \"flags\": \"T\",\n  \"value\": \"IGP\"  // or EGP or INCOMPLETE\n}\n</code></pre>"},{"location":"json-format/#aspath","title":"ASPATH","text":"<p>AS path as an array. AS sequences are flat arrays, AS sets are nested arrays:</p> <pre><code>\"ASPATH\": {\n  \"flags\": \"T\",\n  \"value\": [64515, 20473, 15169]  // AS_SEQUENCE\n}\n</code></pre> <p>With AS_SET:</p> <pre><code>\"ASPATH\": {\n  \"flags\": \"T\",\n  \"value\": [64515, [20473, 15169]]  // last is AS_SET\n}\n</code></pre>"},{"location":"json-format/#nexthop","title":"NEXTHOP","text":"<p>IPv4 next-hop address:</p> <pre><code>\"NEXTHOP\": {\n  \"flags\": \"T\",\n  \"value\": \"192.0.2.1\"\n}\n</code></pre>"},{"location":"json-format/#med-multi-exit-discriminator","title":"MED (Multi-Exit Discriminator)","text":"<pre><code>\"MED\": {\n  \"flags\": \"O\",\n  \"value\": 100\n}\n</code></pre>"},{"location":"json-format/#localpref-local-preference","title":"LOCALPREF (Local Preference)","text":"<pre><code>\"LOCALPREF\": {\n  \"flags\": \"T\",\n  \"value\": 200\n}\n</code></pre>"},{"location":"json-format/#community","title":"COMMUNITY","text":"<p>Standard BGP communities as <code>ASN:value</code> strings:</p> <pre><code>\"COMMUNITY\": {\n  \"flags\": \"OT\",\n  \"value\": [\"65000:100\", \"65000:200\"]\n}\n</code></pre>"},{"location":"json-format/#large_community","title":"LARGE_COMMUNITY","text":"<p>Large BGP communities (RFC 8092):</p> <pre><code>\"LARGE_COMMUNITY\": {\n  \"flags\": \"OT\",\n  \"value\": [\"65000:100:1\", \"65000:200:2\"]\n}\n</code></pre>"},{"location":"json-format/#ext_community-extended-communities","title":"EXT_COMMUNITY (Extended Communities)","text":"<p>Extended communities with type-specific encoding:</p> <pre><code>\"EXT_COMMUNITY\": {\n  \"flags\": \"OT\",\n  \"value\": [\n    {\"type\": \"RT\", \"asn\": 65000, \"val\": 100},\n    {\"type\": \"RT\", \"ip\": \"192.0.2.1\", \"val\": 100}\n  ]\n}\n</code></pre> <p>Common types: <code>RT</code> (Route Target), <code>RO</code> (Route Origin), <code>REDIR_IP4</code> (Flowspec redirect), <code>RATE</code> (Flowspec rate-limit).</p>"},{"location":"json-format/#mp-bgp-attributes","title":"MP-BGP Attributes","text":""},{"location":"json-format/#mp_reach","title":"MP_REACH","text":"<p>Multi-protocol reachable NLRI (used for IPv6, Flowspec, etc.):</p> <pre><code>\"MP_REACH\": {\n  \"flags\": \"OX\",\n  \"value\": {\n    \"af\": \"IPV6/UNICAST\",\n    \"nexthop\": \"2001:db8::1\",\n    \"prefixes\": [\"2001:db8:1::/48\", \"2001:db8:2::/48\"]\n  }\n}\n</code></pre> <p>For Flowspec, see the Flowspec section below.</p>"},{"location":"json-format/#mp_unreach","title":"MP_UNREACH","text":"<p>Multi-protocol unreachable NLRI (withdrawals):</p> <pre><code>\"MP_UNREACH\": {\n  \"flags\": \"OX\",\n  \"value\": {\n    \"af\": \"IPV6/UNICAST\",\n    \"prefixes\": [\"2001:db8:3::/48\"]\n  }\n}\n</code></pre>"},{"location":"json-format/#complete-update-example","title":"Complete UPDATE Example","text":"<pre><code>[\n  \"R\",\n  243,\n  \"2025-07-11T11:23:50.860\",\n  \"UPDATE\",\n  {\n    \"reach\": [\"8.8.8.0/24\", \"8.8.4.0/24\"],\n    \"attrs\": {\n      \"ORIGIN\": {\n        \"flags\": \"T\",\n        \"value\": \"IGP\"\n      },\n      \"ASPATH\": {\n        \"flags\": \"T\",\n        \"value\": [64515, 15169]\n      },\n      \"NEXTHOP\": {\n        \"flags\": \"T\",\n        \"value\": \"192.0.2.1\"\n      },\n      \"COMMUNITY\": {\n        \"flags\": \"OT\",\n        \"value\": [\"64515:100\"]\n      }\n    }\n  },\n  {}\n]\n</code></pre>"},{"location":"json-format/#flowspec-messages","title":"Flowspec Messages","text":"<p>Flowspec (Flow Specification) messages are a special type of UPDATE that carries traffic filtering rules instead of routing prefixes. They use the <code>MP_REACH</code> or <code>MP_UNREACH</code> attributes with AFI/SAFI set to <code>IPV4/FLOWSPEC</code> or <code>IPV6/FLOWSPEC</code>.</p>"},{"location":"json-format/#flowspec-in-mp_reach","title":"Flowspec in MP_REACH","text":"<pre><code>\"MP_REACH\": {\n  \"flags\": \"OX\",\n  \"value\": {\n    \"af\": \"IPV4/FLOWSPEC\",\n    \"nexthop\": \"0.0.0.0\",\n    \"rules\": [ ... ]\n  }\n}\n</code></pre>"},{"location":"json-format/#flowspec-rules","title":"Flowspec Rules","text":"<p>Each Flowspec rule is a JSON object with components (match conditions):</p> <pre><code>{\n  \"DST\": \"192.0.2.0/24\",\n  \"SRC\": \"198.51.100.0/24\",\n  \"PROTO\": [{\"op\": \"==\", \"val\": 6}],\n  \"PORT_DST\": [{\"op\": \"==\", \"val\": 80}]\n}\n</code></pre>"},{"location":"json-format/#flowspec-components","title":"Flowspec Components","text":"Component Type Description <code>DST</code> prefix Destination prefix <code>SRC</code> prefix Source prefix <code>PROTO</code> operators IP protocol (e.g., 6=TCP, 17=UDP) <code>PORT</code> operators Source or destination port <code>PORT_DST</code> operators Destination port <code>PORT_SRC</code> operators Source port <code>ICMP_TYPE</code> operators ICMP type <code>ICMP_CODE</code> operators ICMP code <code>TCP_FLAGS</code> bitmask ops TCP flags (bitmask matching) <code>PKTLEN</code> operators Packet length <code>DSCP</code> operators DSCP value <code>FRAG</code> bitmask ops Fragmentation flags (bitmask matching) <code>LABEL</code> operators IPv6 flow label (IPv6 only)"},{"location":"json-format/#numeric-operators","title":"Numeric Operators","text":"<p>For components like <code>PROTO</code>, <code>PORT_DST</code>, etc., the value is an array of operator objects:</p> <pre><code>[\n  {\"op\": \"==\", \"val\": 80},\n  {\"op\": \"&gt;=\", \"val\": 1024, \"and\": true}\n]\n</code></pre> <p>Operator types:</p> <ul> <li><code>==</code>: Equal</li> <li><code>&gt;</code>: Greater than</li> <li><code>&gt;=</code>: Greater than or equal</li> <li><code>&lt;</code>: Less than</li> <li><code>&lt;=</code>: Less than or equal</li> <li><code>!=</code>: Not equal</li> <li><code>true</code>: Always match</li> <li><code>false</code>: Never match</li> </ul> <p>Optional fields:</p> <ul> <li><code>and: true</code>: Logical AND with next condition (default is OR)</li> </ul>"},{"location":"json-format/#bitmask-operators","title":"Bitmask Operators","text":"<p>For <code>TCP_FLAGS</code> and <code>FRAG</code> components:</p> <pre><code>[\n  {\"op\": \"ALL\", \"val\": \"0x12\", \"len\": 1}\n]\n</code></pre> <p>Bitmask operations:</p> <ul> <li><code>ANY</code>: Match if any bit is set</li> <li><code>ALL</code>: Match if all bits are set</li> <li><code>NONE</code>: Match if no bits are set</li> <li><code>NOT-ALL</code>: Match if not all bits are set</li> </ul> <p>Fields:</p> <ul> <li><code>val</code>: Hex string (e.g., <code>0x12</code>) representing the bitmask</li> <li><code>len</code>: Length in bytes (1, 2, 4, or 8)</li> </ul>"},{"location":"json-format/#ipv6-prefix-with-offset","title":"IPv6 Prefix with Offset","text":"<p>For IPv6 Flowspec, prefixes can specify an offset:</p> <pre><code>\"DST\": \"2001:db8::/32-64\"\n</code></pre> <p>Format: <code>address/offset-length</code> where offset is the bit position to start matching from.</p>"},{"location":"json-format/#flowspec-actions-extended-communities","title":"Flowspec Actions (Extended Communities)","text":"<p>Flowspec rules typically have associated actions in extended communities:</p> <pre><code>\"EXT_COMMUNITY\": {\n  \"flags\": \"OT\",\n  \"value\": [\n    {\"type\": \"REDIR_IP4\", \"ip\": \"192.0.2.1\", \"val\": 100},\n    {\"type\": \"RATE\", \"rate\": 0}\n  ]\n}\n</code></pre> <p>Common Flowspec actions:</p> <ul> <li>REDIR_IP4 / REDIR_IP6: Redirect traffic to VRF</li> <li>RATE: Rate limit in bytes/second (0 = discard)</li> <li>MARK: DSCP marking value</li> <li>RT: Route Target (for VRF import/export)</li> </ul>"},{"location":"json-format/#complete-flowspec-example","title":"Complete Flowspec Example","text":"<p>This example blocks TCP traffic to port 80 from a specific prefix:</p> <pre><code>[\n  \"R\",\n  15,\n  \"2025-07-11T10:50:00.000\",\n  \"UPDATE\",\n  {\n    \"attrs\": {\n      \"ORIGIN\": {\n        \"flags\": \"T\",\n        \"value\": \"IGP\"\n      },\n      \"ASPATH\": {\n        \"flags\": \"T\",\n        \"value\": [65055]\n      },\n      \"MP_REACH\": {\n        \"flags\": \"OX\",\n        \"value\": {\n          \"af\": \"IPV4/FLOWSPEC\",\n          \"nexthop\": \"0.0.0.0\",\n          \"rules\": [\n            {\n              \"DST\": \"192.0.2.0/24\",\n              \"PROTO\": [{\"op\": \"==\", \"val\": 6}],\n              \"PORT_DST\": [{\"op\": \"==\", \"val\": 80}]\n            }\n          ]\n        }\n      },\n      \"EXT_COMMUNITY\": {\n        \"flags\": \"OT\",\n        \"value\": [\n          {\"type\": \"RATE\", \"rate\": 0}\n        ]\n      }\n    }\n  },\n  {}\n]\n</code></pre>"},{"location":"json-format/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>Hex Encoding: When the upper layer is not parsed (e.g., unsupported attribute), the JSON value is a hex string like <code>0x1234abcd</code>.</li> <li>Time Format: Timestamps use <code>YYYY-MM-DDTHH:MM:SS.mmm</code> format (millisecond precision).</li> <li>AFI/SAFI Format: Address family identifiers use <code>AFI/SAFI</code> format (e.g., <code>IPV4/UNICAST</code>, <code>IPV6/FLOWSPEC</code>).</li> <li>Prefixes: IP prefixes use standard CIDR notation (e.g., <code>192.0.2.0/24</code>, <code>2001:db8::/32</code>).</li> <li>Bidirectional: The JSON format fully supports both encoding (JSON to BGP wire) and decoding (BGP wire to JSON).</li> </ul>"},{"location":"json-format/#see-also","title":"See Also","text":"<ul> <li>Message Filters - Filter BGP messages using the <code>grep</code> and <code>drop</code> stages</li> <li>Examples - Practical bgpipe command-line examples</li> <li>bgpfix library - The underlying Go library implementing this format</li> </ul>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#installation","title":"Installation","text":"<p>To get started with <code>bgpipe</code>, you need to install it on your system, ie. where you want it to proxy or terminate BGP sessions. <code>bgpipe</code> is a single binary that can be run on any machine, preferably Linux. It does not require any additional libraries or dependencies, making it easy to deploy - just copy the binary to your target machine.</p> <p>You can download pre-built binaries from the GitHub Releases page.</p> <p>Alternatively, you can compile from source. You need to have Go installed first. Then, you can run:</p> <pre><code>go install github.com/bgpfix/bgpipe@latest   # note (1)\n</code></pre> <ol> <li>Make sure to put the resultant <code>bgpipe</code> binary in your <code>$PATH</code>. Go installs executables in the directory named by the <code>$GOBIN</code> environment variable, which defaults to <code>$GOPATH/bin</code>, or <code>$HOME/go/bin</code> if the <code>$GOPATH</code> variable is not set.</li> </ol>"},{"location":"quickstart/#running-bgpipe","title":"Running bgpipe","text":"<p>When you run <code>bgpipe</code> without any arguments, it will print the help message, for example:</p> <pre><code>Usage: bgpipe [OPTIONS] [--] STAGE1 [OPTIONS] [ARGUMENTS] [--] STAGE2...\n\nOptions:\n  -v, --version          print detailed version info and quit\n  -n, --explain          print the pipeline as configured and quit\n  -l, --log string       log level (debug/info/warn/error/disabled) (default \"info\")\n      --pprof string     bind pprof to given listen address\n  -e, --events strings   log given events (\"all\" means all events) (default [PARSE,ESTABLISHED,EOR])\n  -k, --kill strings     kill session on any of these events\n  -i, --stdin            read JSON from stdin\n  -o, --stdout           write JSON to stdout\n  -I, --stdin-wait       like --stdin but wait for EVENT_ESTABLISHED\n  -O, --stdout-wait      like --stdout but wait for EVENT_EOR\n  -2, --short-asn        use 2-byte ASN numbers\n  -g, --guess-asn        guess AS number byte size\n      --caps string      use given BGP capabilities (JSON format)\n\nSupported stages (run &lt;stage&gt; -h to get its help)\n  connect                connect to a BGP endpoint over TCP\n  drop                   drop messages that match a filter\n  exec                   handle messages in a background process\n  grep                   drop messages that DO NOT match a filter\n  limit                  limit prefix lengths and counts\n  listen                 let a BGP client connect over TCP\n  pipe                   process messages through a named pipe\n  read                   read messages from file or URL\n  speaker                run a simple BGP speaker\n  stdin                  read messages from stdin\n  stdout                 print messages to stdout\n  tag                    add or drop message tags\n  update                 modify UPDATE messages\n  websocket              process messages over websocket\n  write                  write messages to file\n</code></pre> <p>From the above output, you can learn the basic syntax of a pipeline, which is a sequence of stages. Usually the stages are separated by <code>--</code> characters; otherwise, <code>bgpipe</code> will try to separate the stages automatically, although this can lead to ambiguities for more complex pipelines. Global <code>bgpipe</code> options are specified before the first stage, and options for each stage are specified immediately after the stage name.</p> <p>A stage is a specific processing step in the pipeline, such as connecting to a BGP endpoint, filtering messages, or executing a command. You can think of it as a building block that performs a specific task in the overall message processing flow. In order to learn more about a specific stage, you can run <code>bgpipe &lt;stage&gt; -h</code>, for example:</p> <pre><code>$ bgpipe connect -h\nStage usage: connect [OPTIONS] ADDR\n\nDescription: connect to a BGP endpoint over TCP\n\nOptions:\n  --timeout duration   TCP connect timeout (0 means off) (default 15s)\n  --closed-timeout duration\n           TCP half-closed timeout (0 means off) (default 1s)\n      --md5 string         TCP MD5 password\n\nCommon Options:\n  -L, --left               operate in the L direction\n  -R, --right              operate in the R direction\n  -A, --args               consume all CLI arguments till --\n  -W, --wait strings       wait for given event before starting\n  -S, --stop strings       stop after given event is handled\n  -N, --new string         which stage to send new messages to (default \"next\")\n  -O, --of string          stage output filter (drop non-matching output)\n</code></pre> <p>As you can see, the <code>connect</code> stage has its own set of options, such as <code>--timeout</code>, <code>--closed-timeout</code>, and <code>--md5</code>, which are specific to establishing a BGP connection. The common options, such as <code>-L</code>, <code>-R</code>, etc. are available for all stages and control how the stage operates in the pipeline context.</p> <p>By default, all stages operate in the right (<code>-R</code>) direction, meaning that they process BGP messages flowing from left to right. The direction controls which messages to capture for processing in a stage, and where to send new messages. However, if the last stage connects to a BGP endpoint, by default it will operate in the left (<code>-L</code>) direction, meaning it will send new messages to the left of the pipeline. Usually, the left-most and/or right-most stage is the one that connects to a BGP endpoint, while the other stages process messages in between. If you want bidirectional processing, use the <code>-L</code> and <code>-R</code> options together, ie. <code>-LR</code>.</p> <p>For writing BGP message filters used by the <code>grep</code> and <code>drop</code> stages, see the dedicated filter reference with attributes, operators, and examples.</p>"},{"location":"quickstart/#reading-mrt-files","title":"Reading MRT files","text":"<p>Let's demonstrate basic message processing by reading MRT files. MRT files are a standard format for storing BGP messages, and <code>bgpipe</code> can read them from a file or a URL. You can even stream MRT files directly from the RIPE NCC RIS or RouteViews archives.</p> <p>Below is an example of reading a compressed MRT file from the RIPE NCC RIS archive, filtering it for a specific prefix, and printing the results to stdout:</p> <pre><code>$ bgpipe \\\n    -- read https://data.ris.ripe.net/rrc01/latest-update.gz \\\n    -- grep 'prefix ~ 8.0.0.0/8' \\\n    -- stdout\n2025-07-04 13:17:47 INF streaming https://data.ris.ripe.net/rrc01/latest-update.gz stage=\"[1] read\"\n[\"R\",6826,\"2025-07-04T13:05:19.000\",\"UPDATE\",{\"reach\":[\"8.20.247.0/24\",\"8.26.56.0/24\",\"104.37.179.0/24\",\"199.167.65.0/24\"],\"attrs\":{\"ORIGIN\":{\"flags\":\"T\",\"value\":\"IGP\"},\"ASPATH\":{\"flags\":\"T\",\"value\":[8218,174,20473,23393]},\"NEXTHOP\":{\"flags\":\"T\",\"value\":\"5.57.80.210\"},\"MED\":{\"flags\":\"O\",\"value\":4},\"COMMUNITY\":{\"flags\":\"OT\",\"value\":[\"8218:102\",\"8218:20000\",\"8218:20110\"]}}},{\"PEER_AS\":\"8218\",\"PEER_IP\":\"5.57.80.210\",\"LOCAL_AS\":\"12654\",\"LOCAL_IP\":\"5.57.80.4\"}]\n[\"R\",7431,\"2025-07-04T13:05:21.000\",\"UPDATE\",{\"reach\":[\"8.20.247.0/24\",\"8.26.56.0/24\",\"104.37.179.0/24\",\"199.167.65.0/24\"],\"attrs\":{\"ORIGIN\":{\"flags\":\"T\",\"value\":\"IGP\"},\"ASPATH\":{\"flags\":\"T\",\"value\":[8218,20473,23393]},\"NEXTHOP\":{\"flags\":\"T\",\"value\":\"5.57.80.210\"},\"MED\":{\"flags\":\"O\",\"value\":4},\"COMMUNITY\":{\"flags\":\"OT\",\"value\":[\"8218:102\",\"8218:20000\",\"8218:20110\"]},\"OTC\":{\"flags\":\"OTP\",\"value\":\"0x00001a79\"}}},{\"LOCAL_AS\":\"12654\",\"LOCAL_IP\":\"5.57.80.4\",\"PEER_AS\":\"8218\",\"PEER_IP\":\"5.57.80.210\"}]\n// ...\n</code></pre> <p>In the above, the <code>read</code> stage streams the latest BGP updates from the <code>rrc01</code> RIPE RIS collector, uncompresses the data on the fly, and sends back to the pipeline for further processing. Next, the <code>grep</code> stage captures these messages, applies a BGP message filter that an IP prefix must overlap with <code>8.0.0.0/8</code>, and sends matching messages to the next stage (non-matching traffic is dropped). Finally, the <code>stdout</code> stage converts the messages to JSON format and prints them to the standard output.</p> <p>Note that <code>bgpipe</code> provides the <code>--explain</code> (short <code>-n</code>) debugging option that prints the pipeline as configured, but without actually running anything. For example:</p> <pre><code>$ bgpipe -n \\\n    -- read https://data.ris.ripe.net/rrc01/latest-update.gz \\\n    -- grep 'prefix ~ 8.0.0.0/8' \\\n    -- stdout\n--&gt; MESSAGES FLOWING RIGHT --&gt;\n  [1] read https://data.ris.ripe.net/rrc01/latest-update.gz\n      writes messages to pipeline inputs=1\n  [2] grep prefix ~ 8.0.0.0/8\n      reads messages from pipeline callbacks=1 types=[ALL]\n  [3] stdout\n      reads messages from pipeline callbacks=1 types=[ALL]\n\n&lt;-- MESSAGES FLOWING LEFT &lt;--\n  (none)\n</code></pre> <p>Last but not least, instead of putting the <code>stdout</code> stage explicitly in the pipeline, you can use the <code>--stdout</code> (short <code>-o</code>) option to <code>bgpipe</code>, in order to print BGP messages to stdout automatically. It will print all messages that make it to the very end of the left-hand side or right-hand side of the pipeline, ie. all messages that are not dropped by any stage.</p> <pre><code>$ bgpipe -o \\\n    -- read https://data.ris.ripe.net/rrc01/latest-update.gz \\\n    -- grep 'prefix ~ 8.0.0.0/8'\n...\n</code></pre>"},{"location":"quickstart/#connecting-to-a-bgp-speaker","title":"Connecting to a BGP speaker","text":"<p>Now that you know how to read MRT files, let's connect to a BGP speaker and process messages in real-time. You can use the <code>connect</code> stage to establish the TCP connection, and the <code>speaker</code> stage to open and maintain a BGP session.</p> <p>We will use this opportunity to connect to one of the BGP projects run by \u0141ukasz Bromirski. The following command connects to the BGP Blackholing with Flowspec endpoint and prints the conversation to stdout, which demonstrates that <code>bgpipe</code> supports Flowspec:</p> <pre><code>$ bgpipe -o \\\n    -- speaker --active --asn 65055 \\\n    -- connect 85.232.240.180\n2025-07-11 10:47:20 INF dialing 85.232.240.180:179 stage=\"[2] connect\"\n2025-07-11 10:47:20 INF connection R_LOCAL = 192.168.200.202:59438 stage=\"[2] connect\"\n2025-07-11 10:47:20 INF connection R_REMOTE = 85.232.240.180:179 stage=\"[2] connect\"\n2025-07-11 10:47:20 INF connected 192.168.200.202:59438 -&gt; 85.232.240.180:179 stage=\"[2] connect\"\n[\"R\",1,\"2025-07-11T08:47:20.650\",\"OPEN\",{\"bgp\":4,\"asn\":65055,\"id\":\"0.0.0.1\",\"hold\":90,\"caps\":{\"MP\":[\"IPV4/UNICAST\",\"IPV4/FLOWSPEC\",\"IPV6/UNICAST\",\"IPV6/FLOWSPEC\"],\"ROUTE_REFRESH\":true,\"EXTENDED_MESSAGE\":true,\"AS4\":65055}},{}]\n[\"L\",1,\"2025-07-11T08:47:22.659\",\"OPEN\",{\"bgp\":4,\"asn\":65055,\"id\":\"85.232.240.180\",\"hold\":7200,\"caps\":{\"MP\":[\"IPV4/FLOWSPEC\"],\"ROUTE_REFRESH\":true,\"EXTENDED_NEXTHOP\":[\"IPV4/UNICAST/IPV6\",\"IPV4/MULTICAST/IPV6\",\"IPV4/MPLS_VPN/IPV6\"],\"AS4\":65055,\"PRE_ROUTE_REFRESH\":true}},{}]\n[\"L\",2,\"2025-07-11T08:47:22.659\",\"KEEPALIVE\",null,{}]\n[\"R\",2,\"2025-07-11T08:47:22.659\",\"KEEPALIVE\",null,{}]\n2025-07-11 10:47:22 INF negotiated session capabilities caps=\"{\\\"MP\\\":[\\\"IPV4/FLOWSPEC\\\"],\\\"ROUTE_REFRESH\\\":true,\\\"AS4\\\":65055}\"\n2025-07-11 10:47:22 INF event bgpfix/pipe.ESTABLISHED evseq=15 vals=[1752223642]\n...\n</code></pre>"},{"location":"quickstart/#proxying-bgp-sessions","title":"Proxying BGP sessions","text":"<p>Let's now see how to use <code>bgpipe</code> to proxy BGP sessions. You can use the <code>listen</code> stage to accept incoming connections on one side, and the <code>connect</code> stage to forward BGP messages to another router on another side. This allows you to create a transparent proxy that can filter, modify, or log BGP messages.</p> <p>For example, let's use the Vultr's BGP feature, where you already have a local BIRD instance, with the following configuration:</p> <pre><code>log syslog all;\nrouter id 1.2.3.4;\n\nprotocol bgp vultr\n{\n  local as 123;\n  source address 1.2.3.4;\n  ipv4 {\n    import none;\n    export none;\n  };\n  graceful restart on;\n  multihop 2;\n  neighbor 169.254.169.254 as 64515;\n  password \"solarwinds123\";\n}\n</code></pre> <p>Let's say you'd like to see all UPDATEs that match a specific ASN <code>15169</code>. First, let's run a <code>bgpipe</code> proxy that listens on port <code>1790</code> and connects to the upstream router with TCP-MD5 when its client connects.</p> <pre><code>$ bgpipe \\\n  -- connect --wait listen --md5 \"solarwinds123\" 169.254.169.254 \\\n  -- stdout -LR --if \"as_path = 15169\" \\\n  -- listen localhost:1790\n2025-07-11 09:16:47 INF listening on 127.0.0.1:1790 stage=\"[3] listen\"\n</code></pre> <p>Now let's reconfigure the BIRD instance to connect to <code>bgpipe</code> instead of the upstream router. Change the <code>neighbor</code> line in the BIRD configuration to point to <code>localhost:1790</code>:</p> <pre><code>// ...\nprotocol bgp vultr\n{\n  // ...\n  neighbor 127.0.0.1 port 1790 as 64515;\n  // password \"\"; // no password needed\n}\n</code></pre> <p>Finally, restart your BIRD instance and you should see <code>bgpipe</code> reporting new connections, followed by JSON representations of BGP messages matching your filter:</p> <pre><code>2025-07-11 11:23:45 INF connection R_LOCAL = 127.0.0.1:1790 stage=\"[3] listen\"\n2025-07-11 11:23:45 INF connection R_REMOTE = 1.2.3.4:36297 stage=\"[3] listen\"\n2025-07-11 11:23:45 INF connected 127.0.0.1:1790 -&gt; 1.2.3.4:36297 stage=\"[3] listen\"\n2025-07-11 11:23:45 INF dialing 169.254.169.254:179 stage=\"[1] connect\"\n2025-07-11 11:23:45 INF connection L_LOCAL = 1.2.3.4:33514 stage=\"[1] connect\"\n2025-07-11 11:23:45 INF connection L_REMOTE = 169.254.169.254:179 stage=\"[1] connect\"\n2025-07-11 11:23:45 INF connected 1.2.3.4:33514 -&gt; 169.254.169.254:179 stage=\"[1] connect\"\n2025-07-11 11:23:46 INF negotiated session capabilities caps=\"{\\\"MP\\\":[\\\"IPV4/UNICAST\\\"],\\\"ROUTE_REFRESH\\\":true,\\\"GRACEFUL_RESTART\\\":true,\\\"AS4\\\":64515,\\\"ENHANCED_ROUTE_REFRESH\\\":true,\\\"LLGR\\\":true}\"\n2025-07-11 11:23:46 INF event bgpfix/pipe.ESTABLISHED evseq=15 vals=[1752233026]\n2025-07-11 11:23:49 INF event bgpfix/pipe.EOR evdir=L evseq=18\n[\"R\",243,\"2025-07-11T11:23:50.860\",\"UPDATE\",{\"reach\":[...],\"attrs\":{\"ORIGIN\":{\"flags\":\"T\",\"value\":\"EGP\"},\"ASPATH\":{\"flags\":\"TX\",\"value\":[64515,65534,20473,15169,396982]},\"NEXTHOP\":{\"flags\":\"T\",\"value\":\"169.254.169.254\"},\"COMMUNITY\":{\"flags\":\"OT\",\"value\":[\"20473:300\",\"20473:15169\",\"64515:44\"]},\"LARGE_COMMUNITY\":{\"flags\":\"OT\",\"value\":[\"20473:300:15169\"]}}},{}]\n...\n</code></pre>"},{"location":"quickstart/#filtering-with-python-scripts","title":"Filtering with Python scripts","text":"<p>The <code>exec</code> stage lets you process BGP messages with external scripts. <code>bgpipe</code> sends JSON arrays (see JSON format docs) to the script's stdin and reads modified/filtered messages from stdout. This makes it easy to implement custom BGP logic in any language.</p> <p>Here's a simple Python script that only allows IPv4 prefixes shorter than <code>/16</code>:</p> <pre><code>#!/usr/bin/env python3\n\nimport sys\nimport json\n\nfor line in sys.stdin:\n    msg = json.loads(line)\n    if msg[3] == \"UPDATE\":\n        if \"reach\" in msg[4]: \n            msg[4][\"reach\"] = [p for p in msg[4][\"reach\"] if int(p.split(\"/\")[1]) &lt; 16]\n            if len(msg[4][\"reach\"]) &gt; 0 :\n                print(json.dumps(msg), flush=True)\n</code></pre> <p>Use it in a pipeline, stop after printing the first 10 messages:</p> <pre><code>chmod +x ./drop-long-prefixes.py\nbgpipe -o \\\n  -- read https://data.ris.ripe.net/rrc01/latest-update.gz \\\n  -- exec ./drop-long-prefixes.py \\\n| head\n</code></pre> <p>The script receives each message as a JSON array <code>[dir, seq, time, type, data, meta]</code>, processes it, and forwards it downstream. You can modify messages, drop them (by not printing), or generate new ones. For bidirectional processing, remember to use the <code>-LR</code> flags on the <code>exec</code> stage.</p>"},{"location":"quickstart/#conclusion","title":"Conclusion","text":"<p>For more practical pipelines and advanced use cases, check out the examples page. It contains real-world bgpipe command lines for BGP monitoring, proxying, filtering, and more.</p> <p>Happy bgpiping!</p>"},{"location":"stages/","title":"Stages","text":"<p>A stage is a processing step in a bgpipe pipeline. Each stage performs a specific task: connecting to a BGP speaker, filtering messages, writing to a file, and so on. Stages are composed left-to-right on the command line, separated by <code>--</code>.</p> <pre><code>bgpipe [OPTIONS] [--] STAGE1 [OPTIONS] [ARGS] [--] STAGE2 [OPTIONS] [ARGS] ...\n</code></pre>"},{"location":"stages/#available-stages","title":"Available Stages","text":""},{"location":"stages/#connection","title":"Connection","text":"Stage Description connect Connect to a BGP endpoint over TCP listen Accept an incoming BGP connection over TCP speaker Run a simple BGP speaker"},{"location":"stages/#input-output","title":"Input / Output","text":"Stage Description stdin Read messages from standard input stdout Write messages to standard output read Read messages from a file or URL write Write messages to a file"},{"location":"stages/#filtering","title":"Filtering","text":"Stage Description grep Keep messages matching a filter; drop the rest drop Drop messages matching a filter; keep the rest tag Add or remove message tags limit Enforce prefix length and count limits head Stop the pipeline after N messages"},{"location":"stages/#modification","title":"Modification","text":"Stage Description update Modify UPDATE message attributes"},{"location":"stages/#external-processing","title":"External Processing","text":"Stage Description exec Pipe messages through an external process pipe Exchange messages through a named pipe (FIFO) websocket Exchange messages over WebSocket"},{"location":"stages/#live-streaming","title":"Live Streaming","text":"Stage Description ris-live Stream BGP updates from RIPE RIS Live rv-live Stream BGP updates from RouteViews via Kafka"},{"location":"stages/#security","title":"Security","text":"Stage Description rpki Validate UPDATE messages using RPKI"},{"location":"stages/#common-options","title":"Common Options","text":"<p>Every stage accepts the following options:</p> Option Description <code>-L</code>, <code>--left</code> Operate in the L (left) direction <code>-R</code>, <code>--right</code> Operate in the R (right) direction <code>-A</code>, <code>--args</code> Consume all remaining CLI arguments until <code>--</code> <code>-W</code>, <code>--wait</code> events Wait for given event(s) before starting <code>-S</code>, <code>--stop</code> events Stop the stage after given event(s) <code>--rate-limit</code> N Delay messages to stay under N messages/sec <code>--rate-sample</code> N Randomly sample messages when over N messages/sec <p>In <code>--wait</code> and <code>--stop</code>, multiple events can be comma-separated. If you refer a stage name (e.g., <code>listen</code>), the event is expanded by appending <code>/READY</code> (e.g., <code>listen/READY</code>), which is emitted when the stage is ready to process messages (e.g., after accepting a new connection). You can also refer to custom events emitted by stages (e.g., <code>grep/match</code>).</p> <p>Stages that support input or output filtering:</p> Option Description <code>-I</code>, <code>--if</code> filters Input filter: skip capturing messages that don't match all the filters <code>-O</code>, <code>--of</code> filters Output filter: drop produced messages that don't match all the filters"},{"location":"stages/#direction","title":"Direction","text":"<p>By default, stages operate in the right (<code>-R</code>) direction, processing messages flowing left-to-right. The last stage that connects to a BGP endpoint defaults to the left (<code>-L</code>) direction instead. Use <code>-LR</code> for bidirectional processing.</p>"},{"location":"stages/#see-also","title":"See Also","text":"<p>Quick Start, Examples, Message Filters, JSON Format</p>"},{"location":"stages/connect/","title":"connect","text":"<p>Connect to a BGP endpoint over TCP.</p>"},{"location":"stages/connect/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- connect [OPTIONS] ADDR\n</code></pre>"},{"location":"stages/connect/#description","title":"Description","text":"<p>The connect stage establishes a TCP connection to a remote BGP speaker at ADDR. It is both a producer and a consumer: it reads BGP messages from the wire and writes pipeline messages to the remote peer.</p> <p>The ADDR argument specifies the target as <code>host</code>, <code>host:port</code>, or <code>[host]:port</code>. If no port is given, the default BGP port 179 is used.</p> <p>By default, connect messages flow left-to-right (<code>-R</code> direction), but if it is the last stage in the pipeline, it defaults to the left (<code>-L</code>) direction, so that incoming messages from the remote peer flow right-to-left through the pipeline.</p> <p>As a shorthand, a bare IP address can be used as a stage name instead of writing <code>connect</code> explicitly:</p> <pre><code>bgpipe -o speaker -- 1.2.3.4\n# equivalent to:\nbgpipe -o speaker -- connect 1.2.3.4\n</code></pre>"},{"location":"stages/connect/#options","title":"Options","text":"Option Type Default Description <code>--timeout</code> duration <code>15s</code> TCP connect timeout; 0 disables <code>--closed-timeout</code> duration <code>1s</code> TCP half-closed timeout; 0 disables <code>--keepalive</code> duration <code>15s</code> TCP keepalive period; -1 disables <code>--md5</code> string TCP MD5 password (RFC 2385) <code>--bind</code> string Local address to bind to (<code>IP</code> or <code>IP:port</code>) <code>--tls</code> bool <code>false</code> Connect over TLS <code>--insecure</code> bool <code>false</code> Skip TLS certificate validation <code>--no-ipv6</code> bool <code>false</code> Avoid IPv6 when resolving ADDR <code>--retry</code> bool <code>false</code> Retry on temporary connection errors <code>--retry-max</code> int <code>0</code> Max retry attempts; 0 means unlimited"},{"location":"stages/connect/#examples","title":"Examples","text":"<p>Connect to a BGP speaker and dump the session as JSON:</p> <pre><code>bgpipe -o -- speaker --active --asn 65001 -- connect 192.0.2.1\n</code></pre> <p>Connect with TCP-MD5 authentication:</p> <pre><code>bgpipe -o -- speaker -- connect --md5 \"s3cret\" 192.0.2.1\n</code></pre> <p>Connect over TLS with retry:</p> <pre><code>bgpipe -o -- speaker -- connect --tls --retry 192.0.2.1:1179\n</code></pre> <p>Bind to a specific local address (multi-homed host):</p> <pre><code>bgpipe -- connect --bind 10.0.0.1 192.0.2.1 -- listen :179\n</code></pre>"},{"location":"stages/connect/#see-also","title":"See Also","text":"<p>listen, speaker, Stages overview</p>"},{"location":"stages/exec/","title":"exec","text":"<p>Pipe messages through an external process.</p>"},{"location":"stages/exec/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- exec [OPTIONS] COMMAND\nbgpipe [...] -- exec -A COMMAND [ARGS...] --\n</code></pre>"},{"location":"stages/exec/#description","title":"Description","text":"<p>The exec stage runs an external command and exchanges BGP messages with it over stdin/stdout. Pipeline messages are serialized (JSON by default) and sent to the command's stdin; the command's stdout is parsed back into messages and injected into the pipeline.</p> <p>This makes it straightforward to process BGP data with any language - Python, Perl, shell scripts, or compiled programs. The external process receives one message per line and can:</p> <ul> <li>Filter: print only messages it wants to keep</li> <li>Modify: alter message contents and print the result</li> <li>Generate: produce new messages on stdout</li> <li>Drop: simply not print a message to discard it</li> </ul> <p>The command's stderr is forwarded to the bgpipe log.</p> <p>The stage is both a producer and a consumer, and supports bidirectional operation with <code>-LR</code>.</p> <p>Use the <code>-A</code> / <code>--args</code> flag to pass arguments to the command. Without <code>-A</code>, only the first argument after <code>exec</code> is treated as the command path. With <code>-A</code>, all arguments up to the next <code>--</code> are passed to the command.</p>"},{"location":"stages/exec/#options","title":"Options","text":"Option Type Default Description <code>--keep-stdin</code> bool <code>false</code> Keep running if the command's stdin is closed <code>--keep-stdout</code> bool <code>false</code> Keep running if the command's stdout is closed <code>--format</code> string <code>json</code> Data format: <code>json</code>, <code>raw</code>, <code>mrt</code>, <code>exa</code>, <code>bmp</code>, or <code>obmp</code> <code>--type</code> strings Process only messages of given type(s) <code>--skip</code> strings Skip messages of given type(s) <code>--read</code> bool <code>false</code> Read-only mode (don't send pipeline output to command) <code>--write</code> bool <code>false</code> Write-only mode (don't read command output) <code>--copy</code> bool <code>false</code> Mirror messages instead of consuming them <code>--pardon</code> bool <code>false</code> Ignore input parsing errors <code>--no-seq</code> bool <code>false</code> Overwrite input sequence numbers <code>--no-time</code> bool <code>false</code> Overwrite input timestamps <code>--no-tags</code> bool <code>false</code> Drop input message tags"},{"location":"stages/exec/#examples","title":"Examples","text":"<p>Filter updates with a Python script:</p> <pre><code>bgpipe -o -- read updates.mrt.gz -- exec -A python3 filter.py --\n</code></pre> <p>Use sed to rewrite ASNs in OPEN messages:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- exec -LR -A sed -ure '/\"OPEN\"/{ s/65055/65001/g }' -- \\\n    -- connect 10.0.0.1\n</code></pre> <p>Process with ExaBGP-compatible scripts:</p> <pre><code>bgpipe \\\n    -- listen :179 \\\n    -- exec --format exa -LR -A /path/to/script.py -- \\\n    -- connect 192.0.2.1\n</code></pre> <p>Write-only: send messages to a monitoring script without reading back:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- exec --write -LR -A /usr/local/bin/bgp-logger -- \\\n    -- connect 10.0.0.1\n</code></pre>"},{"location":"stages/exec/#python-script-example","title":"Python Script Example","text":"<p>A Python script that filters IPv4 prefixes shorter than /16:</p> <pre><code>#!/usr/bin/env python3\nimport sys, json\n\nfor line in sys.stdin:\n    msg = json.loads(line)\n    if msg[3] == \"UPDATE\":\n        if \"reach\" in msg[4]:\n            msg[4][\"reach\"] = [\n                p for p in msg[4][\"reach\"]\n                if int(p.split(\"/\")[1]) &lt; 16\n            ]\n            if not msg[4][\"reach\"]:\n                continue\n    print(json.dumps(msg), flush=True)\n</code></pre>"},{"location":"stages/exec/#see-also","title":"See Also","text":"<p>pipe, websocket, JSON Format, Stages overview</p>"},{"location":"stages/grep/","title":"grep / drop","text":"<p>Filter messages by matching against a BGP filter expression.</p>"},{"location":"stages/grep/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- grep [OPTIONS] FILTER\nbgpipe [...] -- drop [OPTIONS] FILTER\n</code></pre>"},{"location":"stages/grep/#description","title":"Description","text":"<p>The grep stage keeps messages that match FILTER and drops the rest. The drop stage does the inverse: it drops matching messages and keeps the rest. Both are the same stage with opposite default behavior.</p> <p>The FILTER argument is a BGP filter expression that tests message attributes such as prefix, AS path, communities, and tags. See the Message Filters reference for complete syntax.</p> <p>This stage supports bidirectional operation with <code>-LR</code>. Without <code>-LR</code>, it processes only messages in the stage direction. It matches UPDATE messages by default; non-UPDATE messages (OPEN, KEEPALIVE, NOTIFICATION) are dropped unless explicitly allowed.</p> <p>With <code>--keep</code>, the stage evaluates the filter but never drops messages. This requires at least one of <code>--event-match</code> or <code>--event-fail</code> so that the filter evaluation has a visible effect.</p> <p>As an alternative to a separate grep stage, most consumer stages support the <code>--if</code> flag, which skips the stage for messages that don't match the filter. For example, <code>stdout --if 'ipv6'</code> prints only IPv6 updates.</p>"},{"location":"stages/grep/#options","title":"Options","text":"Option Type Default Description <code>--keep</code> bool <code>false</code> Evaluate the filter but never drop (requires <code>--event-*</code>) <code>--event-match</code> string Emit this event when a message matches <code>--event-fail</code> string Emit this event when a message does not match <code>--kill-match</code> bool <code>false</code> Kill the process on filter match <code>--kill-fail</code> bool <code>false</code> Kill the process on filter failure"},{"location":"stages/grep/#examples","title":"Examples","text":"<p>Keep only IPv6 updates:</p> <pre><code>bgpipe -o -- read updates.mrt.gz -- grep 'ipv6'\n</code></pre> <p>Drop updates with AS path containing AS64512:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- drop 'as_path ~ ,64512,' \\\n    -- connect 10.0.0.1\n</code></pre> <p>Filter updates by origin AS and prefix:</p> <pre><code>bgpipe -o -- read updates.mrt.gz -- grep 'as_origin == 15169 &amp;&amp; prefix ~ 8.8.0.0/16'\n</code></pre> <p>Emit an event on match without dropping:</p> <pre><code>bgpipe --events grep/hijack \\\n    -- connect 192.0.2.1 \\\n    -- grep --keep --event-match hijack 'prefix ~ 192.0.2.0/24 &amp;&amp; as_origin != 64496' \\\n    -- connect 10.0.0.1\n</code></pre> <p>Kill the session if a default route is announced:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- grep --keep --kill-match --event-match default 'prefix == 0.0.0.0/0' \\\n    -- connect 10.0.0.1\n</code></pre> <p>Use <code>--if</code> on a stage instead of a separate grep:</p> <pre><code>bgpipe -o -- read updates.mrt.gz -- stdout --if 'as_origin == 15169'\n</code></pre>"},{"location":"stages/grep/#see-also","title":"See Also","text":"<p>Message Filters, tag, limit, Stages overview</p>"},{"location":"stages/head/","title":"head","text":"<p>Stop the pipeline after a fixed number of messages.</p>"},{"location":"stages/head/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- head [OPTIONS]\n</code></pre>"},{"location":"stages/head/#description","title":"Description","text":"<p>The head stage lets only the first N messages pass and then stops the pipeline. This is useful for sampling or quick tests against a live source.</p> <p>The message count is taken from messages seen in the stage direction (or both when using <code>-LR</code>). When the limit is reached, the stage passes that message and stops the pipeline.</p>"},{"location":"stages/head/#options","title":"Options","text":"Option Type Default Description <code>-n</code>, <code>--count</code> int <code>10</code> Number of messages to pass before stopping"},{"location":"stages/head/#examples","title":"Examples","text":"<p>Stop after 20 updates from a live session:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- head -n 20 \\\n    -- stdout\n</code></pre> <p>Sample 100 messages in both directions:</p> <pre><code>bgpipe \\\n    -- listen :179 \\\n    -- head -LR -n 100 \\\n    -- connect 192.0.2.1\n</code></pre>"},{"location":"stages/head/#see-also","title":"See Also","text":"<p>grep, limit, Stages overview</p>"},{"location":"stages/limit/","title":"limit","text":"<p>Enforce prefix length and count limits.</p>"},{"location":"stages/limit/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- limit [OPTIONS]\n</code></pre>"},{"location":"stages/limit/#description","title":"Description","text":"<p>The limit stage enforces constraints on BGP UPDATE messages to prevent prefix flooding attacks (such as the Kirin attack). It tracks announced prefixes and drops messages that violate configured limits.</p> <p>The stage supports three types of count limits:</p> <ul> <li>Session limit (<code>--session</code>): maximum total prefixes across the session</li> <li>Origin limit (<code>--origin</code>): maximum prefixes per origin AS</li> <li>Block limit (<code>--block</code>): maximum prefixes per IP address block</li> </ul> <p>Prefix length limits (<code>--min-length</code>, <code>--max-length</code>) reject individual prefixes that are too specific or too broad.</p> <p>Use <code>--ipv4</code> and/or <code>--ipv6</code> to select which address families to process. If neither is specified, only IPv4 is processed. Use separate limit stages for different limits on IPv4 and IPv6.</p> <p>The stage tracks prefix state across the session lifetime, correctly handling both announcements and withdrawals (unless <code>--permanent</code> is set).</p> <p>This stage supports bidirectional operation with <code>-LR</code>, aggregating counts from both directions. Without <code>-LR</code>, it tracks only the stage direction.</p>"},{"location":"stages/limit/#options","title":"Options","text":"Option Type Default Description <code>-4</code>, <code>--ipv4</code> bool <code>false</code> Process IPv4 prefixes (default if neither -4 nor -6 given) <code>-6</code>, <code>--ipv6</code> bool <code>false</code> Process IPv6 prefixes <code>--multicast</code> bool <code>false</code> Include multicast address families <code>--permanent</code> bool <code>false</code> Ignore withdrawals (announcements are permanent) <code>-m</code>, <code>--min-length</code> int <code>0</code> Minimum prefix length; 0 disables <code>-M</code>, <code>--max-length</code> int <code>0</code> Maximum prefix length; 0 disables <code>-s</code>, <code>--session</code> int <code>0</code> Global session prefix limit; 0 disables <code>-o</code>, <code>--origin</code> int <code>0</code> Per-AS origin prefix limit; 0 disables <code>-b</code>, <code>--block</code> int <code>0</code> Per-IP-block prefix limit; 0 disables <code>-B</code>, <code>--block-length</code> int <code>0</code> IP block prefix length (max 64); 0 means /16 (IPv4) or /32 (IPv6)"},{"location":"stages/limit/#events","title":"Events","text":"<p>The stage emits events prefixed with <code>limit/</code> when limits are violated:</p> Event Trigger <code>limit/short</code> Prefix shorter than <code>--min-length</code> <code>limit/long</code> Prefix exceeds <code>--max-length</code> <code>limit/session</code> Session prefix count exceeds <code>--session</code> <code>limit/origin</code> Per-origin prefix count exceeds <code>--origin</code> <code>limit/block</code> Per-block prefix count exceeds <code>--block</code> <p>Use <code>--events limit/session</code> on bgpipe to log these events, or <code>--kill limit/session</code> to terminate the session when a limit is hit.</p>"},{"location":"stages/limit/#examples","title":"Examples","text":"<p>Enforce standard prefix length limits for IPv4 and IPv6:</p> <pre><code>bgpipe --kill limit/session \\\n    -- connect 192.0.2.1 \\\n    -- limit -LR -4 --min-length 8 --max-length 24 --session 1000000 \\\n    -- limit -LR -6 --min-length 16 --max-length 48 --session 250000 \\\n    -- connect 10.0.0.1\n</code></pre> <p>Limit per-origin AS prefix count (detect prefix hijack floods):</p> <pre><code>bgpipe --events limit/origin \\\n    -- connect 192.0.2.1 \\\n    -- limit -LR --origin 5000 \\\n    -- connect 10.0.0.1\n</code></pre> <p>Limit per /16 block (IPv4) to detect concentrated floods:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- limit --block 10000 --block-length 16 \\\n    -- connect 10.0.0.1\n</code></pre>"},{"location":"stages/limit/#see-also","title":"See Also","text":"<p>grep, rpki, Kirin Attack, Stages overview</p>"},{"location":"stages/listen/","title":"listen","text":"<p>Accept an incoming BGP connection over TCP.</p>"},{"location":"stages/listen/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- listen [OPTIONS] [ADDR]\n</code></pre>"},{"location":"stages/listen/#description","title":"Description","text":"<p>The listen stage binds to a local TCP address and waits for a single incoming BGP connection. It is both a producer and a consumer: it reads BGP messages from the connected client and writes pipeline messages back to it.</p> <p>The optional ADDR argument specifies the listen address as <code>host:port</code>, <code>:port</code>, or <code>host</code>. Defaults to <code>:179</code> (all interfaces, standard BGP port).</p> <p>Once a client connects, the listener closes and no further connections are accepted.</p> <p>By default, listen messages flow left-to-right (<code>-R</code> direction), but if it is the last stage in the pipeline, it defaults to the left (<code>-L</code>) direction, so that incoming messages flow right-to-left.</p>"},{"location":"stages/listen/#options","title":"Options","text":"Option Type Default Description <code>--timeout</code> duration <code>0</code> Accept timeout; 0 means wait indefinitely <code>--closed-timeout</code> duration <code>1s</code> TCP half-closed timeout; 0 disables <code>--keepalive</code> duration <code>15s</code> TCP keepalive period; -1 disables <code>--md5</code> string TCP MD5 password (Linux only)"},{"location":"stages/listen/#examples","title":"Examples","text":"<p>Listen on the default BGP port and proxy to an upstream router:</p> <pre><code>bgpipe -- connect --wait listen 192.0.2.1 -- listen :179\n</code></pre> <p>Listen on a non-standard port for local BIRD integration:</p> <pre><code>bgpipe -- connect --wait listen --md5 \"s3cret\" 192.0.2.1 -- listen localhost:1790\n</code></pre> <p>Add TCP-MD5 to a session (listen without, connect with):</p> <pre><code>bgpipe -o -- listen :179 -- connect --md5 \"s3cret\" 10.0.0.1\n</code></pre>"},{"location":"stages/listen/#see-also","title":"See Also","text":"<p>connect, speaker, Stages overview</p>"},{"location":"stages/pipe/","title":"pipe","text":"<p>Exchange messages through a named pipe (FIFO).</p>"},{"location":"stages/pipe/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- pipe [OPTIONS] PATH\n</code></pre>"},{"location":"stages/pipe/#description","title":"Description","text":"<p>The pipe stage reads and writes BGP messages through a named pipe (FIFO). It is both a producer and a consumer, and supports bidirectional operation with <code>-LR</code>.</p> <p>The PATH argument specifies the path to a named pipe created with <code>mkfifo(1)</code>. The stage opens the pipe for both reading and writing simultaneously.</p> <p>Messages are exchanged in JSON format by default (one per line).</p>"},{"location":"stages/pipe/#options","title":"Options","text":"Option Type Default Description <code>--format</code> string <code>json</code> Data format: <code>json</code>, <code>raw</code>, <code>mrt</code>, <code>exa</code>, <code>bmp</code>, or <code>obmp</code> <code>--type</code> strings Process only messages of given type(s) <code>--skip</code> strings Skip messages of given type(s) <code>--read</code> bool <code>false</code> Read-only mode <code>--write</code> bool <code>false</code> Write-only mode <code>--copy</code> bool <code>false</code> Mirror messages instead of consuming them <code>--pardon</code> bool <code>false</code> Ignore input parsing errors <code>--no-seq</code> bool <code>false</code> Overwrite input sequence numbers <code>--no-time</code> bool <code>false</code> Overwrite input timestamps <code>--no-tags</code> bool <code>false</code> Drop input message tags"},{"location":"stages/pipe/#examples","title":"Examples","text":"<p>Process messages through a named pipe:</p> <pre><code>mkfifo /tmp/bgp-pipe\nbgpipe \\\n    -- connect 192.0.2.1 \\\n    -- pipe -LR /tmp/bgp-pipe \\\n    -- connect 10.0.0.1\n</code></pre> <p>Write-only: send messages to a pipe for external monitoring:</p> <pre><code>mkfifo /tmp/bgp-monitor\nbgpipe \\\n    -- connect 192.0.2.1 \\\n    -- pipe --write -LR /tmp/bgp-monitor \\\n    -- connect 10.0.0.1\n</code></pre>"},{"location":"stages/pipe/#see-also","title":"See Also","text":"<p>exec, websocket, Stages overview</p>"},{"location":"stages/read/","title":"read","text":"<p>Read messages from a file or URL.</p>"},{"location":"stages/read/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- read [OPTIONS] PATH\n</code></pre>"},{"location":"stages/read/#description","title":"Description","text":"<p>The read stage reads BGP messages from a local file or a remote HTTP/HTTPS URL and injects them into the pipeline. It supports bidirectional operation with <code>-LR</code> and uses the data to set each message direction. Without <code>-LR</code>, messages are injected in the stage direction.</p> <p>The input format is auto-detected by default. Detection first tries the file extension (e.g., <code>.mrt</code> or <code>.json</code>), then falls back to sampling the file contents. Supported formats include JSON (one message per line), MRT (BGP4MP), raw BGP wire format, ExaBGP line format, BMP (BGP Monitoring Protocol), and OpenBMP.</p> <p>Compressed files are decompressed automatically when <code>--decompress</code> is set to <code>auto</code> (the default). The compression format is detected from the file extension: <code>.gz</code> (gzip), <code>.bz2</code> (bzip2), <code>.zst</code> / <code>.zstd</code> (Zstandard).</p> <p>For remote URLs, the stage streams data directly without downloading the entire file first, making it suitable for large MRT archives.</p>"},{"location":"stages/read/#options","title":"Options","text":"Option Type Default Description <code>--decompress</code> string <code>auto</code> Decompression: <code>auto</code>, <code>gz</code>, <code>bzip2</code>, <code>zstd</code>, or <code>none</code> <code>--format</code> string <code>auto</code> Data format: <code>json</code>, <code>raw</code>, <code>mrt</code>, <code>exa</code>, <code>bmp</code>, <code>obmp</code>, or <code>auto</code> <code>--type</code> strings Process only messages of given type(s) <code>--skip</code> strings Skip messages of given type(s) <code>--pardon</code> bool <code>false</code> Ignore input parsing errors <code>--no-seq</code> bool <code>false</code> Overwrite input sequence numbers <code>--no-time</code> bool <code>false</code> Overwrite input timestamps <code>--no-tags</code> bool <code>false</code> Drop input message tags"},{"location":"stages/read/#examples","title":"Examples","text":"<p>Read a compressed MRT file from the RIPE RIS archive:</p> <pre><code>bgpipe -o -- read https://data.ris.ripe.net/rrc01/latest-update.gz\n</code></pre> <p>Read a local MRT file and filter for a prefix:</p> <pre><code>bgpipe -o -- read updates.20240301.0000.bz2 -- grep 'prefix ~ 8.0.0.0/8'\n</code></pre> <p>Convert MRT to JSON:</p> <pre><code>bgpipe -- read updates.mrt.gz -- write output.json\n</code></pre> <p>Replay an MRT file into a live BGP session after establishment:</p> <pre><code>bgpipe \\\n    -- speaker --active --asn 65001 \\\n    -- read --wait ESTABLISHED updates.mrt.zst \\\n    -- listen :179\n</code></pre>"},{"location":"stages/read/#see-also","title":"See Also","text":"<p>write, stdin, Stages overview</p>"},{"location":"stages/ris-live/","title":"ris-live","text":"<p>Stream BGP updates from RIPE RIS Live.</p>"},{"location":"stages/ris-live/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- ris-live [OPTIONS]\n</code></pre>"},{"location":"stages/ris-live/#description","title":"Description","text":"<p>The ris-live stage connects to the RIPE NCC RIS Live streaming service and injects real-time BGP updates into the pipeline. RIS Live aggregates BGP data from RIPE RIS route collectors worldwide, providing a global view of Internet routing without requiring your own BGP peering sessions.</p> <p>The stage connects via Server-Sent Events (SSE) to the RIS Live endpoint, extracts raw BGP messages from the stream, and injects them into the pipeline. Each message is tagged with peer and collector metadata:</p> Tag Description <code>PEER_IP</code> IP address of the BGP peer <code>PEER_AS</code> AS number of the BGP peer <code>RIS_ID</code> RIS collector peer ID <code>RIS_HOST</code> RIS collector hostname (e.g., <code>rrc01.ris.ripe.net</code>) <code>COLLECTOR</code> Short collector name derived from RIS_HOST (e.g., <code>rrc01</code>) <p>These tags can be used in downstream filters, for example: <code>tag[PEER_AS] == 13335</code> or <code>tag[RIS_HOST] ~ \"rrc01\"</code>.</p> <p>Connection retries are enabled by default. The stage monitors message freshness and treats stale messages (older than <code>--delay-err</code>) as connection errors, triggering a reconnect.</p> <p>Use <code>--sub</code> to pass a RIS Live subscription filter to limit the data at the source. The subscription JSON must include <code>\"includeRaw\": true</code> for bgpipe to process the raw BGP messages.</p> <p>The global <code>-g</code> / <code>--guess-asn</code> flag is recommended when using this stage, as different RIS peers may use 2-byte or 4-byte ASNs.</p>"},{"location":"stages/ris-live/#options","title":"Options","text":"Option Type Default Description <code>--url</code> string (RIS Live endpoint) Override the streaming endpoint URL <code>--sub</code> string RIS Subscribe JSON filter <code>--timeout</code> duration <code>10s</code> Connect timeout; 0 disables <code>--read-timeout</code> duration <code>10s</code> Max time between messages before reconnecting <code>--retry</code> bool <code>true</code> Retry connection on errors <code>--retry-max</code> int <code>0</code> Max retry attempts; 0 means unlimited <code>--delay-err</code> duration <code>3m</code> Treat messages older than this as errors; 0 disables"},{"location":"stages/ris-live/#examples","title":"Examples","text":"<p>Stream all RIS Live updates and print to stdout:</p> <pre><code>bgpipe -go -- ris-live\n</code></pre> <p>Monitor a specific prefix in real-time:</p> <pre><code>bgpipe -go -- ris-live -- grep 'prefix ~ 1.1.1.0/24'\n</code></pre> <p>Subscribe to a specific collector:</p> <pre><code>bgpipe -go -- ris-live --sub '{\"host\":\"rrc01\",\"includeRaw\":true}'\n</code></pre> <p>Stream with RPKI validation, show only invalid:</p> <pre><code>bgpipe -go \\\n    -- ris-live \\\n    -- rpki --invalid keep \\\n    -- grep 'tag[rpki/status] == INVALID'\n</code></pre> <p>Archive RIS Live to compressed files with hourly rotation:</p> <pre><code>bgpipe -g \\\n    -- ris-live \\\n    -- write --every 1h 'ris-live.$TIME.mrt.gz'\n</code></pre>"},{"location":"stages/ris-live/#see-also","title":"See Also","text":"<p>rv-live, read, RIPE RIS Live, Stages overview</p>"},{"location":"stages/rpki/","title":"rpki","text":"<p>Validate UPDATE messages using RPKI.</p>"},{"location":"stages/rpki/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- rpki [OPTIONS]\n</code></pre>"},{"location":"stages/rpki/#description","title":"Description","text":"<p>The rpki stage validates BGP UPDATE messages against RPKI (Resource Public Key Infrastructure) data. It checks whether the origin AS is authorized to announce each prefix, based on ROA (Route Origin Authorization) records.</p> <p>Each prefix in an UPDATE is assigned one of three RPKI validation states:</p> <ul> <li>VALID - a ROA exists and matches the origin AS and prefix length</li> <li>INVALID - a ROA exists but the origin AS or prefix length does not match</li> <li>NOT_FOUND - no ROA covers this prefix</li> </ul> <p>The stage obtains ROA data either from an RTR (RPKI-to-Router) server or from a local ROA file. By default, it connects to Cloudflare's public RTR server at <code>rtr.rpki.cloudflare.com:8282</code>.</p> <p>The <code>--invalid</code> option controls how INVALID prefixes are handled:</p> Action Behavior <code>withdraw</code> Move invalid prefixes to the withdrawn list (RFC 7606) <code>filter</code> Remove invalid prefixes from the reachable list <code>drop</code> Drop the entire UPDATE if any prefix is invalid <code>split</code> Split invalid prefixes into a separate UPDATE that withdraws them <code>keep</code> Keep invalid prefixes unchanged (tag only) <p>When <code>--tag</code> is enabled (the default), the stage adds <code>rpki/status</code> to message tags, which can be used in downstream filters (e.g., <code>tag[rpki/status] == INVALID</code>).</p> <p>With <code>--strict</code>, prefixes with NOT_FOUND status are treated the same as INVALID. This is an aggressive policy that only allows prefixes with explicit RPKI authorization.</p> <p>The stage waits for the ROA cache to be populated before processing messages (unless <code>--asap</code> is set), ensuring no messages are validated against an incomplete cache.</p>"},{"location":"stages/rpki/#options","title":"Options","text":""},{"location":"stages/rpki/#rtr-connection","title":"RTR Connection","text":"Option Type Default Description <code>--rtr</code> string <code>rtr.rpki.cloudflare.com:8282</code> RTR server address (<code>host:port</code>) <code>--rtr-refresh</code> duration <code>1h</code> RTR cache refresh interval <code>--rtr-retry</code> duration <code>10m</code> RTR retry interval on errors <code>--timeout</code> duration <code>15s</code> Connect timeout; 0 disables <code>--retry</code> bool <code>true</code> Retry connection on errors <code>--retry-max</code> int <code>0</code> Max retry attempts; 0 means unlimited <code>--tls</code> bool <code>false</code> Connect to RTR server over TLS <code>--insecure</code> bool <code>false</code> Skip TLS certificate validation <code>--no-ipv6</code> bool <code>false</code> Avoid IPv6 when connecting to RTR server"},{"location":"stages/rpki/#roa-file","title":"ROA File","text":"Option Type Default Description <code>--file</code> string Use a local ROA file instead of RTR (JSON or CSV, auto-reloaded)"},{"location":"stages/rpki/#validation-policy","title":"Validation Policy","text":"Option Type Default Description <code>--invalid</code> string <code>withdraw</code> Action for INVALID prefixes: <code>withdraw</code>, <code>filter</code>, <code>drop</code>, <code>split</code>, <code>keep</code> <code>--strict</code> bool <code>false</code> Treat NOT_FOUND same as INVALID <code>--tag</code> bool <code>true</code> Add <code>rpki/status</code> to message tags <code>--event</code> string Emit this event on RPKI INVALID messages <code>--asap</code> bool <code>false</code> Start validating before ROA cache is ready"},{"location":"stages/rpki/#examples","title":"Examples","text":"<p>Basic RPKI filtering between two routers (default: withdraw invalid):</p> <pre><code>bgpipe \\\n    -- listen :179 \\\n    -- rpki \\\n    -- connect 192.0.2.1\n</code></pre> <p>Keep invalid prefixes but tag them for downstream processing:</p> <pre><code>bgpipe -o \\\n    -- ris-live \\\n    -- rpki --invalid keep \\\n    -- grep 'tag[rpki/status] == INVALID'\n</code></pre> <p>Strict mode: only allow RPKI-VALID prefixes:</p> <pre><code>bgpipe --events rpki/dropped \\\n    -- listen :179 \\\n    -- rpki --strict --invalid drop --event dropped \\\n    -- connect 192.0.2.1\n</code></pre> <p>Use a local ROA file instead of RTR:</p> <pre><code>bgpipe \\\n    -- listen :179 \\\n    -- rpki --file /var/lib/rpki/roas.json --invalid filter \\\n    -- connect 192.0.2.1\n</code></pre> <p>Tag with RPKI status and add a community to invalid routes:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- rpki --invalid keep \\\n    -- update --if 'tag[rpki/status] == INVALID' --add-com 65000:666 \\\n    -- connect 10.0.0.1\n</code></pre> <p>Connect to an RTR server over TLS:</p> <pre><code>bgpipe \\\n    -- listen :179 \\\n    -- rpki --rtr rpki.example.com:8323 --tls \\\n    -- connect 192.0.2.1\n</code></pre>"},{"location":"stages/rpki/#see-also","title":"See Also","text":"<p>limit, grep, update, RFC 6811 - RPKI-Based Origin Validation, Stages overview</p>"},{"location":"stages/rv-live/","title":"rv-live","text":"<p>Stream BGP updates from RouteViews via Kafka.</p>"},{"location":"stages/rv-live/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- rv-live [OPTIONS]\n</code></pre>"},{"location":"stages/rv-live/#description","title":"Description","text":"<p>The rv-live stage consumes real-time BGP updates from the University of Oregon RouteViews project via its public Kafka stream. RouteViews collects BGP data from routers at major Internet exchange points and transit providers worldwide.</p> <p>The stream carries BGP messages in OpenBMP raw format. The stage parses BMP messages, extracts the inner BGP messages, and injects them into the pipeline with peer metadata as tags:</p> Tag Description <code>PEER_IP</code> IP address of the BGP peer <code>PEER_AS</code> AS number of the BGP peer <code>COLLECTOR</code> RouteViews collector name (e.g., <code>linx</code>) <code>ROUTER</code> Router IP address <p>These tags can be used in downstream filters, for example: <code>tag[COLLECTOR] ~ \"linx\"</code> or <code>tag[PEER_AS] == 13335</code>.</p> <p>By default, the stage subscribes to all topics matching the pattern <code>^routeviews\\..+\\.bmp_raw$</code>, which covers all RouteViews collectors. Use <code>--collector</code> to select specific collectors by name prefix, or <code>--topics</code> to supply a custom topic regex.</p> <p>RouteViews injects the collector's own AS into the AS_PATH of each message. By default, this stage strips that first hop. Use <code>--keep-aspath</code> to preserve the original AS_PATH as received from the collector.</p> <p>The <code>--state</code> option enables offset persistence: the stage saves its Kafka consumer position to a file and resumes from the same point on restart. This prevents re-processing messages after a pipeline restart.</p> <p>Connection retries are enabled by default. The stage monitors data freshness and reconnects when no data arrives for <code>--stale</code> duration.</p> <p>The global <code>-g</code> / <code>--guess-asn</code> flag is recommended when using this stage, as different RouteViews peers may use 2-byte or 4-byte ASNs.</p>"},{"location":"stages/rv-live/#options","title":"Options","text":"Option Type Default Description <code>--broker</code> string <code>stream.routeviews.org:9092</code> Kafka broker address <code>--topics</code> string <code>^routeviews\\..+\\.bmp_raw$</code> Topic regex pattern <code>--collector</code> strings Only subscribe to collectors whose name starts with this prefix <code>--collector-not</code> strings Exclude collectors whose name starts with this prefix <code>--group</code> string (auto-generated) Kafka consumer group ID <code>--state</code> string State file for offset persistence <code>--refresh</code> duration <code>5m</code> Topic list refresh interval <code>--timeout</code> duration <code>30s</code> Connection timeout <code>--stale</code> duration <code>3m</code> Reconnect if no data for this long; 0 disables <code>--retry</code> bool <code>true</code> Retry connection on errors <code>--retry-max</code> int <code>0</code> Max retry attempts; 0 means unlimited <code>--keep-aspath</code> bool <code>false</code> Keep the collector AS in AS_PATH"},{"location":"stages/rv-live/#examples","title":"Examples","text":"<p>Stream all RouteViews updates to stdout:</p> <pre><code>bgpipe -go -- rv-live\n</code></pre> <p>Stream from a specific collector:</p> <pre><code>bgpipe -go -- rv-live --collector linx\n</code></pre> <p>Exclude specific collectors:</p> <pre><code>bgpipe -go -- rv-live --collector-not amsix --collector-not decix\n</code></pre> <p>Persist consumer state for resumable processing:</p> <pre><code>bgpipe -go -- rv-live --state /var/lib/bgpipe/rv-live.state\n</code></pre> <p>Archive RouteViews data with RPKI validation:</p> <pre><code>bgpipe -g \\\n    -- rv-live \\\n    -- rpki --invalid keep \\\n    -- write --every 1h 'rv-updates.$TIME.json.gz'\n</code></pre>"},{"location":"stages/rv-live/#see-also","title":"See Also","text":"<p>ris-live, read, RouteViews, Stages overview</p>"},{"location":"stages/speaker/","title":"speaker","text":"<p>Run a simple BGP speaker.</p>"},{"location":"stages/speaker/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- speaker [OPTIONS]\n</code></pre>"},{"location":"stages/speaker/#description","title":"Description","text":"<p>The speaker stage implements BGP session negotiation. It handles OPEN message exchange, KEEPALIVE generation, and hold timer management. Use it when bgpipe needs to participate as a BGP peer rather than passively proxying an existing session.</p> <p>In passive mode (default), the speaker waits for the remote side to send an OPEN message first, then responds with its own OPEN. In active mode (<code>--active</code>), it sends its OPEN immediately.</p> <p>The speaker automatically negotiates BGP capabilities (MP-BGP, 4-byte ASN, Route Refresh, Extended Messages) with the remote peer. When <code>--asn</code> is set to -1, the speaker mirrors the remote peer's ASN. When <code>--id</code> is empty, it derives a router ID from the remote peer's ID.</p> <p>A speaker stage is not needed when bgpipe operates as a transparent proxy between two BGP speakers that negotiate with each other directly.</p>"},{"location":"stages/speaker/#options","title":"Options","text":"Option Type Default Description <code>--active</code> bool <code>false</code> Send the OPEN message first <code>--asn</code> int <code>-1</code> Local ASN; -1 means mirror the remote ASN <code>--id</code> string Router ID; empty means derive from remote <code>--hold</code> int <code>90</code> Hold time in seconds"},{"location":"stages/speaker/#examples","title":"Examples","text":"<p>Connect to a BGP speaker in active mode:</p> <pre><code>bgpipe -o -- speaker --active --asn 65001 -- connect 192.0.2.1\n</code></pre> <p>Passive speaker that mirrors the remote ASN (useful for testing):</p> <pre><code>bgpipe -o -- speaker -- listen :179\n</code></pre> <p>Speaker with explicit identity:</p> <pre><code>bgpipe -o -- speaker --active --asn 64512 --id 10.0.0.1 -- connect 192.0.2.1\n</code></pre> <p>Replay an MRT file into a live BGP session:</p> <pre><code>bgpipe \\\n    -- speaker --active --asn 65001 \\\n    -- read --wait ESTABLISHED updates.mrt.gz \\\n    -- listen :179\n</code></pre>"},{"location":"stages/speaker/#see-also","title":"See Also","text":"<p>connect, listen, Stages overview</p>"},{"location":"stages/stdin/","title":"stdin","text":"<p>Read messages from standard input.</p>"},{"location":"stages/stdin/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- stdin [OPTIONS]\n</code></pre>"},{"location":"stages/stdin/#description","title":"Description","text":"<p>The stdin stage reads BGP messages from standard input and injects them into the pipeline. It is a producer stage that supports bidirectional operation with <code>-LR</code>: in that case, the direction of each message is taken from the input when available (for JSON, the <code>dir</code> field). Otherwise, messages are injected in the stage direction.</p> <p>The default input format is JSON (one message per line). Supported formats also include MRT (BGP4MP), raw BGP wire format, ExaBGP line format, BMP, and OpenBMP - select with <code>--format</code>.</p> <p>As a shorthand, the global <code>-i</code> / <code>--stdin</code> flag adds an implicit stdin stage at the beginning of the pipeline. The <code>-I</code> / <code>--stdin-wait</code> variant waits for <code>EVENT_ESTABLISHED</code> before reading.</p>"},{"location":"stages/stdin/#options","title":"Options","text":"Option Type Default Description <code>--format</code> string <code>json</code> Data format: <code>json</code>, <code>raw</code>, <code>mrt</code>, <code>exa</code>, <code>bmp</code>, or <code>obmp</code> <code>--type</code> strings Process only messages of given type(s) <code>--skip</code> strings Skip messages of given type(s) <code>--pardon</code> bool <code>false</code> Ignore input parsing errors <code>--no-seq</code> bool <code>false</code> Overwrite input sequence numbers <code>--no-time</code> bool <code>false</code> Overwrite input timestamps <code>--no-tags</code> bool <code>false</code> Drop input message tags"},{"location":"stages/stdin/#examples","title":"Examples","text":"<p>Pipe JSON messages into a BGP session:</p> <pre><code>cat messages.json | bgpipe -i -- speaker --active --asn 65001 -- connect 192.0.2.1\n</code></pre> <p>Read MRT from stdin explicitly:</p> <pre><code>cat updates.mrt | bgpipe -- stdin --format mrt -- stdout\n</code></pre>"},{"location":"stages/stdin/#see-also","title":"See Also","text":"<p>stdout, read, Stages overview</p>"},{"location":"stages/stdout/","title":"stdout","text":"<p>Write messages to standard output.</p>"},{"location":"stages/stdout/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- stdout [OPTIONS]\n</code></pre>"},{"location":"stages/stdout/#description","title":"Description","text":"<p>The stdout stage writes BGP messages to standard output. It is a consumer stage that supports bidirectional operation with <code>-LR</code>; without <code>-LR</code>, it prints only messages in the stage direction.</p> <p>The stage always mirrors messages - it never consumes them from the pipeline, so downstream stages still see every message that stdout prints.</p> <p>The default output format is JSON (one message per line). Use <code>--format</code> to select MRT, raw, ExaBGP line, BMP, or OpenBMP format instead.</p> <p>As a shorthand, the global <code>-o</code> / <code>--stdout</code> flag adds an implicit stdout stage at the end of the pipeline. The <code>-O</code> / <code>--stdout-wait</code> variant waits for <code>EVENT_EOR</code> (End of RIB) before printing.</p>"},{"location":"stages/stdout/#options","title":"Options","text":"Option Type Default Description <code>--format</code> string <code>json</code> Data format: <code>json</code>, <code>raw</code>, <code>mrt</code>, <code>exa</code>, <code>bmp</code>, or <code>obmp</code> <code>--type</code> strings Print only messages of given type(s) <code>--skip</code> strings Skip messages of given type(s)"},{"location":"stages/stdout/#examples","title":"Examples","text":"<p>Print all messages as JSON:</p> <pre><code>bgpipe -- read updates.mrt.gz -- stdout\n</code></pre> <p>Print only after the BGP session is established:</p> <pre><code>bgpipe -O -- speaker --active --asn 65001 -- connect 192.0.2.1\n</code></pre> <p>Print in ExaBGP line format:</p> <pre><code>bgpipe -- read updates.mrt.gz -- stdout --format exa\n</code></pre> <p>Print only UPDATE messages:</p> <pre><code>bgpipe -- read updates.mrt.gz -- stdout --type UPDATE\n</code></pre>"},{"location":"stages/stdout/#see-also","title":"See Also","text":"<p>stdin, write, JSON Format, Stages overview</p>"},{"location":"stages/tag/","title":"tag","text":"<p>Add or remove message tags.</p>"},{"location":"stages/tag/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- tag [OPTIONS]\n</code></pre>"},{"location":"stages/tag/#description","title":"Description","text":"<p>The tag stage manipulates key-value pairs (tags) attached to BGP messages as they flow through the pipeline. Tags are metadata that travel with messages but are not part of the BGP wire format. They appear in the <code>meta</code> field of the JSON representation.</p> <p>Tags are useful for:</p> <ul> <li>Annotating messages with pipeline context (e.g., source collector, timestamp)</li> <li>Passing information between stages (e.g., from rpki to grep)</li> <li>Filtering based on custom criteria using <code>tag[key]</code> in filter expressions</li> </ul> <p>This stage supports bidirectional operation with <code>-LR</code>. Without <code>-LR</code>, it applies only to messages in the stage direction.</p>"},{"location":"stages/tag/#options","title":"Options","text":"Option Type Default Description <code>--add</code> strings Add tags in <code>key=value</code> format <code>--drop</code> strings Drop tags by key; use <code>*</code> to drop all tags <code>--src</code> bool <code>false</code> Add a <code>SRC</code> tag with the source stage name"},{"location":"stages/tag/#examples","title":"Examples","text":"<p>Add a tag to all messages:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- tag --add source=upstream1 \\\n    -- write -LR session.json \\\n    -- connect 10.0.0.1\n</code></pre> <p>Strip all tags before writing:</p> <pre><code>bgpipe -- read tagged-data.json -- tag --drop '*' -- write clean.json\n</code></pre> <p>Tag and filter: add environment tag, then filter on it downstream:</p> <pre><code>bgpipe -o \\\n    -- read updates.mrt.gz \\\n    -- tag --add env=prod \\\n    -- grep 'tag[env] == prod'\n</code></pre>"},{"location":"stages/tag/#see-also","title":"See Also","text":"<p>grep, Message Filters, JSON Format, Stages overview</p>"},{"location":"stages/update/","title":"update","text":"<p>Modify UPDATE message attributes.</p>"},{"location":"stages/update/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- update [OPTIONS]\n</code></pre>"},{"location":"stages/update/#description","title":"Description","text":"<p>The update stage modifies BGP UPDATE messages in-flight. It can rewrite next-hop addresses and manipulate community attributes. Non-UPDATE messages pass through unchanged.</p> <p>This stage supports bidirectional operation with <code>-LR</code>. Without <code>-LR</code>, it applies only to messages in the stage direction. Combine with <code>--if</code> to apply modifications only to messages matching a filter.</p>"},{"location":"stages/update/#options","title":"Options","text":""},{"location":"stages/update/#next-hop","title":"Next-hop","text":"Option Type Default Description <code>--nexthop4</code> string Set next-hop for IPv4 prefixes to this address <code>--nexthop6</code> string Set next-hop for IPv6 prefixes to this address <code>--nexthop-self</code> bool <code>false</code> Set next-hop to our own IP address (when available)"},{"location":"stages/update/#communities","title":"Communities","text":"Option Type Default Description <code>--add-com</code> string Add a standard BGP community (<code>ASN:value</code>) <code>--add-com-ext</code> string Add an extended BGP community <code>--add-com-large</code> string Add a large BGP community (<code>G:L1:L2</code>) <code>--drop-com</code> bool <code>false</code> Remove the COMMUNITY attribute entirely <code>--drop-com-ext</code> bool <code>false</code> Remove the EXT_COMMUNITY attribute entirely <code>--drop-com-large</code> bool <code>false</code> Remove the LARGE_COMMUNITY attribute entirely"},{"location":"stages/update/#examples","title":"Examples","text":"<p>Rewrite next-hop for all updates:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- update --nexthop4 10.0.0.1 \\\n    -- connect 10.0.0.1\n</code></pre> <p>Add a community to tag traffic from a specific peer:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- update --add-com 65000:100 \\\n    -- connect 10.0.0.1\n</code></pre> <p>Strip all communities before forwarding:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- update --drop-com --drop-com-ext --drop-com-large \\\n    -- connect 10.0.0.1\n</code></pre> <p>Conditionally modify: add a community only to RPKI-invalid updates:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- rpki --invalid keep \\\n    -- update --if 'tag[rpki/status] == INVALID' --add-com 65000:666 \\\n    -- connect 10.0.0.1\n</code></pre> <p>Set next-hop to self (useful when proxying):</p> <pre><code>bgpipe \\\n    -- listen :179 \\\n    -- update --nexthop-self \\\n    -- connect 192.0.2.1\n</code></pre>"},{"location":"stages/update/#see-also","title":"See Also","text":"<p>grep, rpki, Stages overview</p>"},{"location":"stages/websocket/","title":"websocket","text":"<p>Exchange messages over WebSocket.</p>"},{"location":"stages/websocket/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- websocket [OPTIONS] URL\n</code></pre>"},{"location":"stages/websocket/#description","title":"Description","text":"<p>The websocket stage sends and receives BGP messages over a WebSocket connection. It supports both client mode (connecting to a remote server) and server mode (<code>--listen</code>), with optional TLS encryption and HTTP basic authentication.</p> <p>The URL argument specifies the WebSocket endpoint. Schemes <code>ws://</code> and <code>wss://</code> are used directly; <code>http://</code> and <code>https://</code> are automatically converted to <code>ws://</code> and <code>wss://</code> respectively.</p> <p>In server mode (<code>--listen</code>), the stage accepts multiple concurrent WebSocket clients and broadcasts messages to all connected clients. If a non-critical client disconnects, the stage continues operating. In server mode with <code>wss://</code>, both <code>--cert</code> and <code>--key</code> are required.</p> <p>In client mode (default), the stage connects to a single remote server. Use <code>--retry</code> to automatically reconnect on connection failures.</p> <p>Incoming messages from WebSocket peers are tagged with <code>websocket/remote</code> containing the remote address, which can be used in downstream filters (e.g., <code>tag[websocket/remote] ~ \"10.0.\"</code>).</p> <p>This stage is both a producer and a consumer, and supports bidirectional operation with <code>-LR</code>.</p>"},{"location":"stages/websocket/#options","title":"Options","text":""},{"location":"stages/websocket/#connection","title":"Connection","text":"Option Type Default Description <code>--listen</code> bool <code>false</code> Run as WebSocket server instead of client <code>--timeout</code> duration <code>10s</code> Connect/handshake timeout; 0 disables <code>--retry</code> bool <code>false</code> Retry client connection on errors <code>--retry-max</code> int <code>0</code> Max retry attempts; 0 means unlimited"},{"location":"stages/websocket/#authentication-and-tls","title":"Authentication and TLS","text":"Option Type Default Description <code>--auth</code> string HTTP basic auth; <code>$ENV_VAR</code> or file path containing <code>user:pass</code> <code>--cert</code> string TLS certificate file path (required for <code>wss://</code> server) <code>--key</code> string TLS private key file path (required for <code>wss://</code> server) <code>--insecure</code> bool <code>false</code> Skip TLS certificate validation <code>--header</code> strings Additional HTTP headers (<code>Header:Value</code> format)"},{"location":"stages/websocket/#data-format","title":"Data Format","text":"Option Type Default Description <code>--format</code> string <code>json</code> Data format: <code>json</code>, <code>raw</code>, <code>mrt</code>, <code>exa</code>, <code>bmp</code>, or <code>obmp</code> <code>--type</code> strings Process only messages of given type(s) <code>--skip</code> strings Skip messages of given type(s) <code>--read</code> bool <code>false</code> Read-only mode <code>--write</code> bool <code>false</code> Write-only mode <code>--copy</code> bool <code>false</code> Mirror messages instead of consuming them <code>--pardon</code> bool <code>false</code> Ignore input parsing errors <code>--no-seq</code> bool <code>false</code> Overwrite input sequence numbers <code>--no-time</code> bool <code>false</code> Overwrite input timestamps <code>--no-tags</code> bool <code>false</code> Drop input message tags"},{"location":"stages/websocket/#examples","title":"Examples","text":"<p>Stream a BGP session to a remote archiver (write-only):</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- websocket --write -LR wss://monitor.example.com/bgp \\\n    -- connect 10.0.0.1\n</code></pre> <p>Connect with authentication from an environment variable:</p> <pre><code>export BGP_AUTH=\"user:s3cret\"\nbgpipe \\\n    -- connect 192.0.2.1 \\\n    -- websocket --write -LR --auth '$BGP_AUTH' wss://monitor.example.com/bgp \\\n    -- connect 10.0.0.1\n</code></pre> <p>Run a WebSocket server for remote clients:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- websocket -LR --listen --cert server.crt --key server.key wss://0.0.0.0:8443/bgp \\\n    -- connect 10.0.0.1\n</code></pre> <p>Client with retry (reconnects on disconnection):</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- websocket -LR --retry wss://monitor.example.com/bgp \\\n    -- connect 10.0.0.1\n</code></pre>"},{"location":"stages/websocket/#see-also","title":"See Also","text":"<p>exec, pipe, Stages overview</p>"},{"location":"stages/write/","title":"write","text":"<p>Write messages to a file.</p>"},{"location":"stages/write/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- write [OPTIONS] PATH\n</code></pre>"},{"location":"stages/write/#description","title":"Description","text":"<p>The write stage writes BGP messages to a local file. It is a consumer that supports bidirectional operation with <code>-LR</code> and mirrors messages flowing through the pipeline, serializing them to disk without consuming them - downstream stages still see every message.</p> <p>The PATH argument supports time-based placeholders for automatic file rotation:</p> <ul> <li><code>$TIME</code> is replaced with the current time formatted according to <code>--time-format</code></li> <li><code>${format}</code> uses a custom Go time format (e.g., <code>${2006-01-02}</code>)</li> </ul> <p>When <code>--every</code> is set, the stage rotates to a new file at the given interval. The minimum rotation interval is 60 seconds.</p> <p>Files are written atomically: data is first written to a <code>.tmp</code> file, then renamed to the final path on successful completion. Empty files are removed automatically. Parent directories are created as needed.</p> <p>The output format is auto-detected from the file extension by default. For example, <code>output.json</code> selects JSON, <code>output.mrt</code> selects MRT. Compression is also auto-detected: <code>.gz</code> (gzip), <code>.bz2</code> (bzip2), <code>.zst</code> / <code>.zstd</code> (Zstandard).</p>"},{"location":"stages/write/#options","title":"Options","text":"Option Type Default Description <code>--format</code> string <code>auto</code> Data format: <code>json</code>, <code>raw</code>, <code>mrt</code>, <code>exa</code>, <code>bmp</code>, <code>obmp</code>, or <code>auto</code> (detected from extension) <code>--append</code> bool <code>false</code> Append to file if it already exists <code>--create</code> bool <code>false</code> Fail if the file already exists <code>--compress</code> string <code>auto</code> Compression: <code>auto</code>, <code>gz</code>, <code>bzip2</code>, <code>zstd</code>, or <code>none</code> <code>--every</code> duration <code>0</code> Rotate to a new file at this interval (min 60s) <code>--time-format</code> string <code>20060102.1504</code> Go time format for <code>$TIME</code> placeholder <code>--type</code> strings Write only messages of given type(s) <code>--skip</code> strings Skip messages of given type(s)"},{"location":"stages/write/#examples","title":"Examples","text":"<p>Write a BGP session to a JSON file:</p> <pre><code>bgpipe -- connect 192.0.2.1 -- write -LR session.json -- connect 10.0.0.1\n</code></pre> <p>Write compressed MRT with hourly rotation:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- write -LR --every 1h 'updates.$TIME.mrt.gz' \\\n    -- connect 10.0.0.1\n</code></pre> <p>Archive only UPDATE messages:</p> <pre><code>bgpipe -- read input.mrt.gz -- write --type UPDATE updates.json\n</code></pre> <p>Append to an existing log:</p> <pre><code>bgpipe -- read new-data.mrt.gz -- write --append archive.json\n</code></pre>"},{"location":"stages/write/#see-also","title":"See Also","text":"<p>read, stdout, Stages overview</p>"}]}