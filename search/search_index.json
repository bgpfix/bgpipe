{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"bgpipe: a BGP firewall","text":"<p>bgpipe is an open-source tool for processing and filtering messages exchanged by the Border Gateway Protocol (BGP). BGP is the routing protocol that makes the Internet work, and as such it is considered to be critical to the global economic prosperity and security.</p> <p>bgpipe operates as a proxy sitting between BGP routers, capable of auditing, fixing, and securing BGP sessions on the fly. It is based on the BGPFix library, distributed under the MIT license, and implemented in Go, making it widely available for many platforms.</p> <p>Started in 2023, bgpipe has its roots in a research project developed at the Institute of Theoretical and Applied Informatics, Polish Academy of Sciences.</p> <ul> <li> <p> What is bgpipe?</p> <p>Understand the basics  Introduction</p> </li> <li> <p> Quick Start</p> <p>Get started in minutes  Quick Start</p> </li> <li> <p> Downloads</p> <p>Download and install bgpipe  GitHub Releases</p> </li> <li> <p> Motivation</p> <p>Read background paper  Kirin Attack</p> </li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Works as a transparent man-in-the-middle proxy.</li> <li>Has full, bi-directional BGP to JSON translation.</li> <li>Can filter and archive BGP sessions through an external process, eg. a Python script.</li> <li>Supports remote processing over encrypted WebSockets (HTTPS), eg. in the cloud.</li> <li>Reads and writes MRT files (BGP4MP), optionally compressed.</li> <li>Compatible with ExaBGP's line-based text format for easy integration.</li> <li>Can add and drop TCP-MD5 on multi-hop BGP sessions, independently on each side.</li> <li>Has built-in BGP message filters and session limiters.</li> <li>Supports popular BGP RFCs, including Flowspec.</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Below are practical examples to help you get started with  <code>bgpipe</code>  after you went through the quickstart guide. These examples demonstrate how to use  <code>bgpipe</code>  for various BGP-related tasks, such as connecting to BGP speakers, reading MRT files, filtering messages, and more.</p>"},{"location":"examples/#connect-to-a-bgp-speaker","title":"Connect to a BGP speaker","text":"<p>Connect to a BGP speaker and respond to OPEN message using the same ASN. Note that if an IP address is used as a stage, it is a shorthand for <code>connect &lt;ip&gt;</code>. The command dumps the session in JSON format to stdout, since the <code>-o</code> option is enabled. It's useful for debugging and monitoring BGP sessions, allowing you to see the raw BGP messages.</p> <pre><code>bgpipe -o speaker -- 1.2.3.4\n</code></pre>"},{"location":"examples/#json-to-bgp-and-back","title":"JSON to BGP and back","text":"<p>Convert a JSON input file to BGP messages, send them to a BGP speaker, and capture the output back in JSON format. This example is useful for testing BGP message processing in remote speakers.</p> <pre><code>cat input.json \\\n  | bgpipe -io speaker -- 1.2.3.4 \\\n  | tee output.json\n</code></pre>"},{"location":"examples/#convert-mrt-files-to-json","title":"Convert MRT files to JSON","text":"<p>Read MRT updates from a compressed file and convert the updates to JSON format. This is particularly useful for analyzing historical BGP data stored in MRT files, which are often used for archiving BGP updates.</p> <pre><code>bgpipe \\\n  -- read --mrt updates.20230301.0000.bz2 \\\n  -- write output.json\n</code></pre>"},{"location":"examples/#adding-tcp-md5","title":"Adding TCP-MD5","text":"<p>Set up a proxy that listens on TCP port 179, waits for a connection, and then proxies it to <code>1.2.3.4</code> with a popular TCP-MD5 password. The conversation is printed to stdout. This setup is useful for \"securing\" BGP sessions, ensuring that only authorized peers can establish a TCP connection. It supports multi-hop scenarios.</p> <pre><code>bgpipe -o \\\n  -- listen :179 \\\n  -- connect --wait listen --md5 solarwinds123 1.2.3.4\n</code></pre>"},{"location":"examples/#stream-mrt-files-to-bgp-routers","title":"Stream MRT files to BGP routers","text":"<p>Listen for new connections on TCP port 179. Configure an active BGP speaker for <code>AS65055</code> that streams a given MRT file when the BGP session is established. This example demonstrates how to replay historical BGP data in a live BGP session, which can be useful for testing and analysis.</p> <pre><code>bgpipe \\\n  -- speaker --active --asn 65055 \\\n  -- read --mrt --wait ESTABLISHED updates.20230301.0000.bz2 \\\n  -- listen :179\n</code></pre>"},{"location":"examples/#bgp-sed-in-the-middle-proxy","title":"BGP sed-in-the-middle proxy","text":"<p>Create a BGP proxy that connects <code>1.2.3.4</code> with 85.232.240.179, but rewrites ASNs in their OPEN messages using sed. This is useful for quickly testing and modifying BGP sessions on the fly, allowing you to simulate different network scenarios.</p> <pre><code>bgpipe \\\n  -- connect 1.2.3.4 \\\n  -- exec -LR --args sed -ure '/\"OPEN\"/{ s/65055/65001/g; s/57355/65055/g }' \\\n  -- connect 85.232.240.179\n</code></pre>"},{"location":"examples/#applying-prefix-limits","title":"Applying prefix limits","text":"<p>Filter BGP updates based on prefix lengths and enforce maximum prefix session limits for both IPv4 and IPv6 connections. This helps in managing and securing BGP sessions by limiting the number of prefixes, which can prevent resource exhaustion.</p> <pre><code>bgpipe --kill limit/session \\\n  -- connect 1.2.3.4 \\\n  -- limit -LR --ipv4 --min-length  8 --max-length 24 --session 1000000 \\\n  -- limit -LR --ipv6 --min-length 16 --max-length 48 --session 250000 \\\n  -- connect 5.6.7.8\n</code></pre>"},{"location":"examples/#archive-bgp-sessions-over-encrypted-websockets","title":"Archive BGP sessions over encrypted WebSockets","text":"<p>Stream the BGP session log in JSON format to a remote WebSocket server for real-time monitoring and archiving. This is useful for integrating BGP session data with external monitoring systems, providing a live feed of BGP activity.</p> <pre><code>bgpipe \\\n  -- connect 1.2.3.4 \\\n  -- websocket -LR --write wss://bgpfix.com/archive?user=demo \\\n  -- connect 85.232.240.179\n</code></pre>"},{"location":"examples/#grep-for-bgp-messages-in-live-sessions","title":"Grep for BGP messages in live sessions","text":"<p>Proxy a connection between two BGP peers, allowing only IPv6 updates from origin AS <code>12345</code>. This is useful for environments that wish to only accept IPv6 prefixes from a specific ASN. The <code>grep</code> stage allows for complex filtering based on various criteria such as message type, prefix, AS_PATH, and more.</p> <pre><code>bgpipe \\\n  -- connect 1.2.3.4 \\\n  -- grep 'ipv6 &amp;&amp; as_origin = 12345' \\\n  -- connect 85.232.240.179\n</code></pre>"},{"location":"examples/#exabgp-compatibility","title":"ExaBGP compatibility","text":"<p>Use the <code>--exa</code> flag to read and write ExaBGP line format instead of JSON. This allows integration with existing ExaBGP-based scripts and tools.</p> <pre><code># Process BGP messages with an ExaBGP-compatible script\nbgpipe \\\n  -- connect 1.2.3.4 \\\n  -- exec --exa -LR --args /path/to/script.py \\\n  -- connect 5.6.7.8\n\n# Convert JSON to ExaBGP format\ncat session.json | bgpipe stdin -- stdout --exa\n</code></pre>"},{"location":"filters/","title":"Message Filters","text":""},{"location":"filters/#overview","title":"Overview","text":"<p>This page explains how to write BGP message filters, used eg. in the <code>grep</code> and <code>drop</code> stages in <code>bgpipe</code>. Filters let you keep (<code>grep</code>) or remove (<code>drop</code>) BGP messages based on message type, NLRI/prefixes, next-hop, AS path, communities, tags, and more.</p> <p>Summary:</p> <ul> <li>Use <code>grep &lt;FILTER&gt;</code> to keep only the messages that match FILTER</li> <li>Use <code>drop &lt;FILTER&gt;</code> to remove the messages that match FILTER</li> <li>Use <code>&lt;stage&gt; --if &lt;CONDITION&gt;</code> to skip a stage completely if the message does not match CONDITION first (<code>--if</code> here corresponds to stage input filter)</li> <li>Combine multiple expressions with <code>&amp;&amp;</code> (AND) and <code>||</code> (OR)</li> <li>Use <code>(...)</code> to group and <code>!</code> to negate expressions</li> </ul> <p>Examples:</p> <pre><code># keep only IPv6 updates from AS65000\nbgpipe -o read --mrt updates.mrt.gz \\\n  -- grep 'ipv6 &amp;&amp; as_origin == 65000'\n\n# drop non-IPv6 updates from AS_PATHs that end with ASN matching 204[0-9]+\nbgpipe -o read --mrt updates.mrt.gz \\\n  -- drop '!ipv6 &amp;&amp; as_path ~ ,204[0-9]+$'\n\n# only for UPDATEs originated by AS15169, drop if no prefixes match 8.0.0.0/8\nbgpipe -o read --mrt updates.mrt.gz \\\n  -- grep --if 'as_origin == 15169' 'prefix ~ 8.0.0.0/8'\n</code></pre>"},{"location":"filters/#filter-syntax","title":"Filter Syntax","text":"<p>A filter is made of one or more expressions:</p> <ul> <li>Expression - one of:<ul> <li><code>attribute</code> or <code>attribute[index]</code></li> <li><code>attribute operator value</code> or <code>attribute[index] operator value</code></li> </ul> </li> <li>Chain expressions with <code>&amp;&amp;</code> (AND) and <code>||</code> (OR)</li> <li>Group with <code>( ... )</code></li> <li>Negate with <code>!</code></li> </ul> <p>Where:</p> <ul> <li><code>attribute</code>: which message attribute you want to test, eg. <code>prefix</code>, <code>aspath</code>, etc.</li> <li><code>[index]</code>: an optional selector within that attribute (e.g., <code>aspath[1]</code>, <code>tag[env]</code>)</li> <li><code>operator</code>: value comparison operator (see below)</li> <li><code>value</code>: value to compare against (strings can be double-quoted with <code>\"...\"</code>)</li> </ul> <p>Supported operators:</p> <ul> <li><code>==</code> or <code>=</code>: equality</li> <li><code>!=</code>: inequality (implemented as negated equality)</li> <li><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>: numeric comparisons (where applicable)</li> <li><code>~</code>: match (attribute-specific, e.g., prefix overlap, membership)</li> <li><code>!~</code>: negative match (negated membership)</li> </ul> <p>Values:</p> <ul> <li>Unquoted tokens, or quoted strings <code>\"...\"</code> (supports <code>\\\\</code> escaping)</li> <li>Numbers are parsed as integers or floats (0x... supported for ints)</li> </ul> <p>Important: Most attributes apply to UPDATE messages only. If your filter uses UPDATE-only attributes (e.g., prefix/aspath/communities) and the message is not an UPDATE (e.g., OPEN/KEEPALIVE), that expression evaluates to false. Use <code>type</code> conditions if you want to match non-UPDATE messages.</p>"},{"location":"filters/#attributes","title":"Attributes","text":"<p>Below are the attributes you can use. Some keywords are shortcuts that expand to comparisons on <code>type</code> or <code>af</code>.</p>"},{"location":"filters/#message-type","title":"Message type","text":"<ul> <li><code>type</code>: explicit type comparison</li> <li>Shortcuts: <code>update</code>, <code>open</code>, <code>keepalive</code></li> </ul> <p>Examples:</p> <pre><code>update                     # same as: type == UPDATE\nopen || keepalive          # match session control messages\n!update || type == OPEN    # only OPEN, not UPDATE\n</code></pre>"},{"location":"filters/#address-family","title":"Address family","text":"<ul> <li><code>af</code>: address family (AFI/SAFI)</li> <li>Shortcuts: <code>ipv4</code> (<code>af == IPV4/UNICAST</code>), <code>ipv6</code> (<code>af == IPV6/UNICAST</code>)</li> </ul> <p>Examples:</p> <pre><code>ipv4 &amp;&amp; update\nipv6 &amp;&amp; prefix ~ 2001:db8::/32\n</code></pre>"},{"location":"filters/#nlri-prefixes","title":"NLRI / prefixes","text":"<ul> <li><code>reach</code>: prefixes in MP_REACH or classic IPv4 reachability</li> <li><code>unreach</code>: prefixes in MP_UNREACH or classic IPv4 withdrawals</li> <li><code>prefix</code>: union of <code>reach</code> and <code>unreach</code></li> </ul> <p>Operators:</p> <ul> <li><code>==</code> exact match, e.g. <code>prefix == 203.0.113.0/24</code></li> <li><code>~</code> overlap (subnet) test, e.g. <code>prefix ~ 203.0.113.0/24</code></li> </ul> <p>Examples:</p> <pre><code>prefix ~ 8.0.0.0/8            # any prefix overlapping 8/8\nreach == 203.0.113.0/24       # exact announcement of 203.0.113.0/24\nunreach ~ 2001:db8::/32       # any withdrawal inside 2001:db8::/32\n</code></pre>"},{"location":"filters/#next-hop","title":"Next-hop","text":"<ul> <li><code>nexthop</code> or <code>nh</code>: match next-hop IP</li> </ul> <p>Examples:</p> <pre><code>nh == 192.0.2.1\nnexthop ~ 2001:db8::/64\n</code></pre>"},{"location":"filters/#as-path","title":"AS path","text":"<ul> <li><code>aspath</code> matches full AS_PATH</li> <li><code>aspath[index]</code> matches particular index</li> <li>Shortcuts:<ul> <li><code>as_origin</code> is origin AS (rightmost, index -1)</li> <li><code>as_upstream</code> is upstream of origin (index -2)</li> <li><code>as_peer</code> is neighbor/peer AS (leftmost, index 0)</li> </ul> </li> </ul> <p>Indexing rules:</p> <ul> <li>Numeric indexes pick a specific position: <code>aspath[0]</code> is the leftmost AS (peer).</li> <li>Negative indexes count from the right: <code>aspath[-1]</code> is the origin; <code>aspath[-2]</code> upstream of origin.</li> <li>If you omit the index on the shortcuts, they assume the position above (e.g., <code>as_origin</code> implies <code>[-1]</code>).</li> </ul> <p>Examples:</p> <pre><code>as_origin == 64496\nas_peer != 64512\naspath[1] == 3356\naspath[-2] == 3356\n</code></pre>"},{"location":"filters/#communities","title":"Communities","text":"<ul> <li><code>community</code> or <code>com</code>: standard communities</li> <li><code>com_ext</code>, <code>ext_community</code>, <code>ext_com</code>: extended communities</li> <li><code>com_large</code>, <code>large_community</code>, <code>large_com</code>: large communities</li> </ul> <p>Operators and values:</p> <ul> <li>Use <code>==</code> for exact string match</li> <li>Use <code>~</code> to match against a regular expression</li> <li>Community formats are strings like <code>\"65000:1\"</code> or <code>\"1234:5678:90\"</code></li> </ul> <p>Examples:</p> <pre><code>community ~ \"3356:\"\ncom_large ~ \"1234:5678:9\"\next_community ~ \"rt:65000:1\"\n</code></pre>"},{"location":"filters/#tags-pipeline-context","title":"Tags (pipeline context)","text":"<p>Tags are key/value pairs attached to messages by the <code>tag</code> stage. You can match them with the <code>tag[...]</code> attribute.</p> <p>Indexing rules for tags:</p> <ul> <li>the index is a string key, e.g., <code>tag[env]</code>, <code>tags[region]</code></li> <li><code>==</code> compares the exact tag value</li> <li><code>~</code> can be used for pattern-like matches</li> </ul> <p>Examples:</p> <pre><code>tag[env] == prod\ntags[region] ~ \"^eu-\"\n</code></pre>"},{"location":"intro/","title":"Introduction","text":"<p><code>bgpipe</code> is a unique open-source tool that combines BGP monitoring with active message manipulation capabilities. While traditional BGP tools are often limited to passive observation, <code>bgpipe</code> operates as a transparent proxy between BGP speakers, allowing real-time inspection and modification of BGP messages.</p> <p><code>bgpipe</code> processes BGP messages through a series of stages, where each stage performs specific actions such as message filtering, format conversion, or security enhancement. For example, you can:</p> <ul> <li>Convert BGP messages to JSON and back for easy processing</li> <li>Add TCP-MD5 authentication to existing BGP sessions</li> <li>Filter BGP updates based on prefix lengths or AS paths</li> <li>Apply rate limits and prefix thresholds to prevent flooding attacks</li> <li>Archive BGP sessions to MRT files or remote WebSocket servers</li> <li>Process messages through external programs like Python scripts</li> </ul> <p>See the quickstart guide for a practical introduction to bgpipe. You can also watch the below RIPE88 bgpipe talk.</p> <p>The talk was summarized in June 2024 by Geoff Huston on the APNIC blog as follows:</p> <p>Observing and measuring the dynamic behaviour of BGP has used a small set of tools for quite some time. There\u2019s the BGP Monitoring Protocol (BMP, RFC 7854), there\u2019s the Multi-threaded Routing Toolkit (MRT) for BGP snapshot and update logs, and if you really want to head back to the earliest days of this work, there are scripts to interrogate a router via the command-line interface, CLI. All of these are observation tools, but they cannot alter the BGP messages that are being passed between BGP speakers.</p> <p>The bgpipe tool, presented by Pawe\u0142 Foremski, is an interesting tool that operates both as a BGP \u2018wire sniffer\u2019 but also allows BGP messages to be altered on the fly (Figure 1).</p> <p></p> <p>Internally, the bgpipe process can be configured to invoke supplied \u2018callback\u2019 routines when part of a BGP message matches some provided pattern, such as a particular IP prefix, update attribute patterns or such, and it can also be configured to have \u2018events\u2019 which processing elements in bgpipe can subscribe to. Simple use cases are to take a BGP session and produce a JSON-formatted log of all BGP messages or take an unencrypted BGP session and add TCP-MD5 encryption. More advanced cases can make use of an external call interface to add route validation checks using RPKI credentials.</p> <p>There has been some concern about using IPv6 prefixes to perform a BGP more specific route flooding attack and its possible to use a bgpipe module to perform various forms of prefix thresholds (per origin Autonomous System (AS) or per aggregate prefix) to detect and filter out the effects of such flooding attacks.</p> <p>It\u2019s early days in this work, but it is certainly an intriguing and novel BGP tool.</p>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#installation","title":"Installation","text":"<p>To get started with <code>bgpipe</code>, you need to install it on your system, ie. where you want it to proxy or terminate BGP sessions. <code>bgpipe</code> is a single binary that can be run on any machine with a compatible operating system (preferably Linux). It does not require any additional libraries or dependencies, making it easy to deploy - just copy the binary to your target machine.</p> <p>You can download pre-built binaries from the GitHub Releases page.</p> <p>Alternatively, you can compile from source. You need to have Go installed first. Then, you can run:</p> <pre><code>go install github.com/bgpfix/bgpipe@latest   # note (1)\n</code></pre> <ol> <li>Make sure to put the resultant <code>bgpipe</code> binary in your <code>$PATH</code>. Go installs executables in the directory named by the <code>$GOBIN</code> environment variable, which defaults to <code>$GOPATH/bin</code>, or <code>$HOME/go/bin</code> if the <code>$GOPATH</code> variable is not set.</li> </ol>"},{"location":"quickstart/#running-bgpipe","title":"Running bgpipe","text":"<p>When you run <code>bgpipe</code> without any arguments, it will print the help message, for example:</p> <pre><code>Usage: bgpipe [OPTIONS] [--] STAGE1 [OPTIONS] [ARGUMENTS] [--] STAGE2...\n\nOptions:\n  -v, --version          print detailed version info and quit\n  -n, --explain          print the pipeline as configured and quit\n  -l, --log string       log level (debug/info/warn/error/disabled) (default \"info\")\n      --pprof string     bind pprof to given listen address\n  -e, --events strings   log given events (\"all\" means all events) (default [PARSE,ESTABLISHED,EOR])\n  -k, --kill strings     kill session on any of these events\n  -i, --stdin            read JSON from stdin\n  -o, --stdout           write JSON to stdout\n  -I, --stdin-wait       like --stdin but wait for EVENT_ESTABLISHED\n  -O, --stdout-wait      like --stdout but wait for EVENT_EOR\n  -2, --short-asn        use 2-byte ASN numbers\n      --caps string      use given BGP capabilities (JSON format)\n\nSupported stages (run &lt;stage&gt; -h to get its help)\n  connect                connect to a BGP endpoint over TCP\n  drop                   drop messages that match a filter\n  exec                   handle messages in a background process\n  grep                   drop messages that DO NOT match a filter\n  limit                  limit prefix lengths and counts\n  listen                 let a BGP client connect over TCP\n  pipe                   process messages through a named pipe\n  read                   read messages from file or URL\n  speaker                run a simple BGP speaker\n  stdin                  read messages from stdin\n  stdout                 print messages to stdout\n  tag                    add or drop message tags\n  update                 modify UPDATE messages\n  websocket              process messages over websocket\n  write                  write messages to file\n</code></pre> <p>From the above output, you can learn the basic syntax of a pipeline, which is a sequence of stages. Usually the stages are separated by <code>--</code> characters; otherwise, <code>bgpipe</code> will try to separate the stages automatically, although this can lead to ambiguities for more complex pipelines. Global <code>bgpipe</code> options are specified before the first stage, and options for each stage are specified immediately after the stage name.</p> <p>A stage is a specific processing step in the pipeline, such as connecting to a BGP endpoint, filtering messages, or executing a command. You can think of it as a building block that performs a specific task in the overall message processing flow. In order to learn more about a specific stage, you can run <code>bgpipe &lt;stage&gt; -h</code>, for example:</p> <pre><code>$ bgpipe connect -h\nStage usage: connect [OPTIONS] ADDR\n\nDescription: connect to a BGP endpoint over TCP\n\nOptions:\n      --timeout duration   connect timeout (0 means none) (default 1m0s)\n      --closed duration    half-closed timeout (0 means none) (default 1s)\n      --md5 string         TCP MD5 password\n\nCommon Options:\n  -L, --left               operate in the L direction\n  -R, --right              operate in the R direction\n  -A, --args               consume all CLI arguments till --\n  -W, --wait strings       wait for given event before starting\n  -S, --stop strings       stop after given event is handled\n  -N, --new string         which stage to send new messages to (default \"next\")\n  -O, --of string          stage output filter (drop non-matching output)\n</code></pre> <p>As you can see, the <code>connect</code> stage has its own set of options, such as <code>--timeout</code>, <code>--closed</code>, and <code>--md5</code>, which are specific to establishing a BGP connection. The common options, such as <code>-L</code>, <code>-R</code>, etc. are available for all stages and control how the stage operates in the pipeline context.</p> <p>By default, all stages operate in the right (<code>-R</code>) direction, meaning that they process BGP messages flowing from left to right. The direction controls which messages to capture for processing in a stage, and where to send new messages. However, if the last stage connects to a BGP endpoint, by default it will operate in the left (<code>-L</code>) direction, meaning it will send new messages to the left of the pipeline. Usually, the left-most and/or right-most stage is the one that connects to a BGP endpoint, while the other stages process messages in between. If you want bidirectional processing, use the <code>-L</code> and <code>-R</code> options together, ie. <code>-LR</code>.</p> <p>For writing BGP message filters used by the <code>grep</code> and <code>drop</code> stages, see the dedicated filter reference with attributes, operators, and examples.</p>"},{"location":"quickstart/#reading-mrt-files","title":"Reading MRT files","text":"<p>Let's demonstrate basic message processing by reading MRT files. MRT files are a standard format for storing BGP messages, and <code>bgpipe</code> can read them from a file or a URL. You can even stream MRT files directly from the RIPE NCC RIS or RouteViews archives.</p> <p>Below is an example of reading a compressed MRT file from the RIPE NCC RIS archive, filtering it for a specific prefix, and printing the results to stdout:</p> <pre><code>$ bgpipe \\\n    -- read --mrt https://data.ris.ripe.net/rrc01/latest-update.gz \\\n    -- grep 'prefix ~ 8.0.0.0/8' \\\n    -- stdout\n2025-07-04 13:17:47 INF streaming https://data.ris.ripe.net/rrc01/latest-update.gz stage=\"[1] read\"\n[\"R\",6826,\"2025-07-04T13:05:19.000\",74,\"UPDATE\",{\"reach\":[\"8.20.247.0/24\",\"8.26.56.0/24\",\"104.37.179.0/24\",\"199.167.65.0/24\"],\"attrs\":{\"ORIGIN\":{\"flags\":\"T\",\"value\":\"IGP\"},\"ASPATH\":{\"flags\":\"T\",\"value\":[8218,174,20473,23393]},\"NEXTHOP\":{\"flags\":\"T\",\"value\":\"5.57.80.210\"},\"MED\":{\"flags\":\"O\",\"value\":4},\"COMMUNITY\":{\"flags\":\"OT\",\"value\":[\"8218:102\",\"8218:20000\",\"8218:20110\"]}}},{\"PEER_AS\":\"8218\",\"PEER_IP\":\"5.57.80.210\",\"LOCAL_AS\":\"12654\",\"LOCAL_IP\":\"5.57.80.4\"}]\n[\"R\",7431,\"2025-07-04T13:05:21.000\",77,\"UPDATE\",{\"reach\":[\"8.20.247.0/24\",\"8.26.56.0/24\",\"104.37.179.0/24\",\"199.167.65.0/24\"],\"attrs\":{\"ORIGIN\":{\"flags\":\"T\",\"value\":\"IGP\"},\"ASPATH\":{\"flags\":\"T\",\"value\":[8218,20473,23393]},\"NEXTHOP\":{\"flags\":\"T\",\"value\":\"5.57.80.210\"},\"MED\":{\"flags\":\"O\",\"value\":4},\"COMMUNITY\":{\"flags\":\"OT\",\"value\":[\"8218:102\",\"8218:20000\",\"8218:20110\"]},\"OTC\":{\"flags\":\"OTP\",\"value\":\"0x00001a79\"}}},{\"LOCAL_AS\":\"12654\",\"LOCAL_IP\":\"5.57.80.4\",\"PEER_AS\":\"8218\",\"PEER_IP\":\"5.57.80.210\"}]\n// ...\n</code></pre> <p>In the above, the <code>read</code> stage streams the latest BGP updates from the <code>rrc01</code> RIPE RIS collector, uncompresses the data on the fly, and sends back to the pipeline for further processing. Next, the <code>grep</code> stage captures these messages, applies a BGP message filter (IP prefix must overlap with the <code>8.0.0.0/8</code> IPv4 prefix), and sends accepted messages to the next stage (non-matching traffic is dropped). Finally, the <code>stdout</code> stage converts the messages to JSON format and prints them to stdout. See filters for more filter examples and details.</p> <p><code>bgpipe</code> provides the <code>--explain</code> (short <code>-n</code>) debugging option that prints the pipeline as configured, but without actually running anything. For example:</p> <pre><code>$ bgpipe -n \\\n    -- read --mrt https://data.ris.ripe.net/rrc01/latest-update.gz \\\n    -- grep 'prefix ~ 8.0.0.0/8' \\\n    -- stdout\n--&gt; MESSAGES FLOWING RIGHT --&gt;\n  [1] read --mrt https://data.ris.ripe.net/rrc01/latest-update.gz\n      writes messages to pipeline inputs=1\n  [2] grep prefix ~ 8.0.0.0/8\n      reads messages from pipeline callbacks=1 types=[ALL]\n  [3] stdout\n      reads messages from pipeline callbacks=1 types=[ALL]\n\n&lt;-- MESSAGES FLOWING LEFT &lt;--\n  (none)\n</code></pre> <p>Last but not least, instead of putting the <code>stdout</code> stage explicitly in the pipeline, you can use the <code>--stdout</code> (short <code>-o</code>) option to <code>bgpipe</code>, in order to print BGP messages to stdout automatically. It will print all messages that make it to the very end of the left-hand side and right-hand side of the pipeline, ie. all messages that are not dropped by any stage.</p> <pre><code>$ bgpipe -o \\\n    -- read --mrt https://data.ris.ripe.net/rrc01/latest-update.gz \\\n    -- grep 'prefix ~ 8.0.0.0/8'\n...\n</code></pre>"},{"location":"quickstart/#connecting-to-a-bgp-speaker","title":"Connecting to a BGP speaker","text":"<p>Now that you know how to read MRT files, let's connect to a BGP speaker and process messages in real-time. You can use the <code>connect</code> stage to establish the TCP connection, and the <code>speaker</code> stage to open and maintain a BGP session.</p> <p>We will use this opportunity to connect to one of the BGP projects run by \u0141ukasz Bromirski. The following command connects to the BGP Blackholing with Flowspec endpoint and prints the conversation to stdout, which demonstrates that <code>bgpipe</code> supports Flowspec:</p> <pre><code>$ bgpipe -o \\\n    -- speaker --active --asn 65055 \\\n    -- connect 85.232.240.180\n2025-07-11 10:47:20 INF dialing 85.232.240.180:179 stage=\"[2] connect\"\n2025-07-11 10:47:20 INF connection R_LOCAL = 192.168.200.202:59438 stage=\"[2] connect\"\n2025-07-11 10:47:20 INF connection R_REMOTE = 85.232.240.180:179 stage=\"[2] connect\"\n2025-07-11 10:47:20 INF connected 192.168.200.202:59438 -&gt; 85.232.240.180:179 stage=\"[2] connect\"\n[\"R\",1,\"2025-07-11T08:47:20.650\",-1,\"OPEN\",{\"bgp\":4,\"asn\":65055,\"id\":\"0.0.0.1\",\"hold\":90,\"caps\":{\"MP\":[\"IPV4/UNICAST\",\"IPV4/FLOWSPEC\",\"IPV6/UNICAST\",\"IPV6/FLOWSPEC\"],\"ROUTE_REFRESH\":true,\"EXTENDED_MESSAGE\":true,\"AS4\":65055}},{}]\n[\"L\",1,\"2025-07-11T08:47:22.659\",56,\"OPEN\",{\"bgp\":4,\"asn\":65055,\"id\":\"85.232.240.180\",\"hold\":7200,\"caps\":{\"MP\":[\"IPV4/FLOWSPEC\"],\"ROUTE_REFRESH\":true,\"EXTENDED_NEXTHOP\":[\"IPV4/UNICAST/IPV6\",\"IPV4/MULTICAST/IPV6\",\"IPV4/MPLS_VPN/IPV6\"],\"AS4\":65055,\"PRE_ROUTE_REFRESH\":true}},{}]\n[\"L\",2,\"2025-07-11T08:47:22.659\",0,\"KEEPALIVE\",null,{}]\n[\"R\",2,\"2025-07-11T08:47:22.659\",0,\"KEEPALIVE\",null,{}]\n2025-07-11 10:47:22 INF negotiated session capabilities caps=\"{\\\"MP\\\":[\\\"IPV4/FLOWSPEC\\\"],\\\"ROUTE_REFRESH\\\":true,\\\"AS4\\\":65055}\"\n2025-07-11 10:47:22 INF event bgpfix/pipe.ESTABLISHED evseq=15 vals=[1752223642]\n...\n</code></pre>"},{"location":"quickstart/#proxying-bgp-sessions","title":"Proxying BGP sessions","text":"<p>Finally, let's see how to use <code>bgpipe</code> to proxy BGP sessions. You can use the <code>listen</code> stage to accept incoming connections and the <code>connect</code> stage to forward BGP messages to another router. This allows you to create a transparent proxy that can filter, modify, or log BGP messages.</p> <p>For example, let's use the Vultr's BGP feature, where you already have a local BIRD instance running on a VM, with the following configuration:</p> <pre><code>log syslog all;\nrouter id 1.2.3.4;\n\nprotocol bgp vultr\n{\n  local as 123;\n  source address 1.2.3.4;\n  ipv4 {\n    import none;\n    export none;\n  };\n  graceful restart on;\n  multihop 2;\n  neighbor 169.254.169.254 as 64515;\n  password \"solarwinds123\";\n}\n</code></pre> <p>Let's say you'd like to see all UPDATEs that match a specific ASN <code>15169</code>. First, let's run a <code>bgpipe</code> proxy that listens on port <code>1790</code> and connects to the upstream router with TCP-MD5 when its client connects.</p> <pre><code>$ bgpipe \\\n  -- connect --wait listen --md5 \"solarwinds123\" 169.254.169.254 \\\n  -- stdout -LR --if \"as_path = 15169\" \\\n  -- listen localhost:1790\n2025-07-11 09:16:47 INF listening on 127.0.0.1:1790 stage=\"[3] listen\"\n</code></pre> <p>Now let's reconfigure the BIRD instance to connect to <code>bgpipe</code> instead of the upstream router. Change the <code>neighbor</code> line in the BIRD configuration to point to <code>localhost:1790</code>:</p> <pre><code>// ...\nprotocol bgp vultr\n{\n  // ...\n  neighbor 127.0.0.1 port 1790 as 64515;\n  // password \"\"; // no password needed\n}\n</code></pre> <p>Finally, restart your BIRD instance and you should see <code>bgpipe</code> reporting new connections, followed by JSON representations of BGP messages matching your filter:</p> <pre><code>2025-07-11 11:23:45 INF connection R_LOCAL = 127.0.0.1:1790 stage=\"[3] listen\"\n2025-07-11 11:23:45 INF connection R_REMOTE = 1.2.3.4:36297 stage=\"[3] listen\"\n2025-07-11 11:23:45 INF connected 127.0.0.1:1790 -&gt; 1.2.3.4:36297 stage=\"[3] listen\"\n2025-07-11 11:23:45 INF dialing 169.254.169.254:179 stage=\"[1] connect\"\n2025-07-11 11:23:45 INF connection L_LOCAL = 1.2.3.4:33514 stage=\"[1] connect\"\n2025-07-11 11:23:45 INF connection L_REMOTE = 169.254.169.254:179 stage=\"[1] connect\"\n2025-07-11 11:23:45 INF connected 1.2.3.4:33514 -&gt; 169.254.169.254:179 stage=\"[1] connect\"\n2025-07-11 11:23:46 INF negotiated session capabilities caps=\"{\\\"MP\\\":[\\\"IPV4/UNICAST\\\"],\\\"ROUTE_REFRESH\\\":true,\\\"GRACEFUL_RESTART\\\":true,\\\"AS4\\\":64515,\\\"ENHANCED_ROUTE_REFRESH\\\":true,\\\"LLGR\\\":true}\"\n2025-07-11 11:23:46 INF event bgpfix/pipe.ESTABLISHED evseq=15 vals=[1752233026]\n2025-07-11 11:23:49 INF event bgpfix/pipe.EOR evdir=L evseq=18\n[\"R\",243,\"2025-07-11T11:23:50.860\",1459,\"UPDATE\",{\"reach\":[...],\"attrs\":{\"ORIGIN\":{\"flags\":\"T\",\"value\":\"EGP\"},\"ASPATH\":{\"flags\":\"TX\",\"value\":[64515,65534,20473,15169,396982]},\"NEXTHOP\":{\"flags\":\"T\",\"value\":\"169.254.169.254\"},\"COMMUNITY\":{\"flags\":\"OT\",\"value\":[\"20473:300\",\"20473:15169\",\"64515:44\"]},\"LARGE_COMMUNITY\":{\"flags\":\"OT\",\"value\":[\"20473:300:15169\"]}}},{}]\n...\n</code></pre>"},{"location":"quickstart/#conclusion","title":"Conclusion","text":"<p>For more practical pipelines and advanced use cases, check out the examples page. It contains real-world bgpipe command lines for BGP monitoring, proxying, filtering, and more.</p> <p>Happy bgpiping!</p>"}]}