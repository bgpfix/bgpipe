{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"bgpipe: BGP pipeline processor","text":"<p>bgpipe is an open-source tool that processes BGP messages through a pipeline of composable stages \u2014 bridging the gaps between monitoring and control.</p> <p>Usually, bgpipe sits between routers as a transparent proxy, auditing, filtering, and transforming BGP sessions on the fly. Built on the bgpfix library, written in Go, and distributed under the MIT license. Started in 2023 as part of a research project at the Polish Academy of Sciences.</p> <ul> <li> <p> Quick Start</p> <p>Get started in minutes  Quick Start</p> </li> <li> <p> Examples</p> <p>See bgpipe in action  Examples</p> </li> <li> <p> Downloads</p> <p>Download and install bgpipe  GitHub Releases</p> </li> <li> <p> Research</p> <p>Read background paper  Kirin Attack</p> </li> </ul>"},{"location":"#quick-demo","title":"Quick Demo","text":"<p>Read live data from RIPE RIS, do real-time RPKI validation using Cloudflare RTR server, and show the first RPKI-invalid announcement.</p> <pre><code>$ bgpipe -go \\\n    -- ris-live \\\n    -- rpki --invalid=keep \\\n    -- grep 'tag[rpki/status] == INVALID' \\\n    -- head -n 1\n</code></pre> <pre><code>[\n    \"R\",\n    10843,\n    \"2026-02-10T12:47:02.900\",\n    \"UPDATE\",\n    {\n        \"reach\":[\"201.49.180.0/23\",\"201.49.181.0/24\"],\n        \"attrs\":{\n            \"ORIGIN\":{\"flags\":\"T\",\"value\":\"IGP\"},\n            \"ASPATH\":{\"flags\":\"T\",\"value\":[199524,174,52320,53062,262907,262907,262907,262907,262907,52900,273801]},\n            \"NEXTHOP\":{\"flags\":\"T\",\"value\":\"196.60.9.188\"}\n        }\n    },\n    {\n        \"PEER_IP\":\"196.60.9.188\",\n        \"PEER_AS\":\"199524\",\n        \"COLLECTOR\":\"rrc19\",\n        \"RIS_HOST\":\"rrc19.ripe.net\",\n        \"RIS_ID\":\"196.60.9.188-019c479748f40019\",\n        \"rpki/201.49.180.0/23\":\"INVALID\",\n        \"rpki/201.49.181.0/24\":\"INVALID\",\n        \"rpki/status\":\"INVALID\",\n    }\n]\n</code></pre>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li> <p> BGP Firewall</p> <p>Drop-in proxy with RPKI validation, prefix limits, and rate limiting</p> </li> <li> <p> Full JSON Translation</p> <p>Bidirectional BGP \u2194 JSON including Flowspec \u2014 pipe through jq, Python, anything</p> </li> <li> <p> MRT Processing</p> <p>Read, convert, and filter compressed MRT archives at scale</p> </li> <li> <p> Scriptable Pipeline</p> <p>Chain stages or pipe messages through external programs</p> </li> <li> <p> Live BGP Monitoring</p> <p>Stream from RIPE RIS Live or RouteViews with real-time filters</p> </li> <li> <p> Secure Transport</p> <p>Add TCP-MD5 to sessions, proxy over encrypted WebSockets</p> </li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Transparent proxy \u2014 sits between two BGP speakers; routers see a normal peer</li> <li>Full JSON translation \u2014 bidirectional BGP \u2194 JSON for every message type, including Flowspec</li> <li>Built-in filters \u2014 match on prefixes, AS paths, communities, attributes, and tags with a concise filter language</li> <li>RPKI validation \u2014 validate UPDATEs against RPKI using RTR protocol (e.g. Cloudflare, Routinator)</li> <li>Prefix and rate limits \u2014 enforce prefix count/length thresholds and message rate limits per session</li> <li>UPDATE rewriting \u2014 add, remove, or modify path attributes on the fly</li> <li>Multiple data formats \u2014 read and write JSON, MRT, BMP, OpenBMP, ExaBGP, and raw BGP wire format</li> <li>Compression support \u2014 transparent gzip/bzip2/zstd for MRT and other file formats</li> <li>HTTP/HTTPS sources \u2014 read directly from URLs (e.g. RouteViews or RIS MRT archives)</li> <li>External program integration \u2014 pipe messages through any process (<code>exec</code>, <code>pipe</code> stages)</li> <li>WebSocket transport \u2014 exchange messages over encrypted WebSockets for remote processing</li> <li>TCP-MD5 handling \u2014 add or drop TCP-MD5 independently on each side of a session</li> <li>Live data feeds \u2014 stream from RIPE RIS Live or RouteViews in real time</li> <li>Message tagging \u2014 attach metadata to messages for downstream filtering and routing decisions</li> <li>20 pipeline stages \u2014 composable building blocks, each doing one thing well (full list)</li> </ul>"},{"location":"#project","title":"Project","text":"<p>bgpipe is hosted on GitHub under the MIT license, built on the bgpfix library.</p> <ul> <li>Report bugs and request features on GitHub Issues</li> <li>For collaboration inquiries, contact bgpipe@bgpipe.org</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Below are practical examples to help you get started with  <code>bgpipe</code>  after you went through the quickstart guide. These examples demonstrate how to use  <code>bgpipe</code>  for various BGP-related tasks, such as connecting to BGP speakers, reading MRT files, filtering messages, and more. For stage details, see the Stages overview and the per-stage docs.</p>"},{"location":"examples/#connect-to-a-bgp-speaker","title":"Connect to a BGP speaker","text":"<p>Stages: speaker, connect, stdout</p> <p>Connect to a BGP speaker and respond to OPEN message using the same ASN. Note that if an IP address is used as a stage, it is a shorthand for <code>connect &lt;ip&gt;</code>. The command dumps the session in JSON format to stdout, since the <code>-o</code> option is enabled. It's useful for debugging and monitoring BGP sessions, allowing you to see the raw BGP messages.</p> <pre><code>bgpipe -o speaker -- 1.2.3.4\n</code></pre>"},{"location":"examples/#json-to-bgp-and-back","title":"JSON to BGP and back","text":"<p>Stages: stdin, speaker, connect, stdout</p> <p>Convert a JSON input file to BGP messages, send them to a BGP speaker, and capture the output back in JSON format. This example is useful for testing BGP message processing in remote speakers.</p> <pre><code>cat input.json \\\n  | bgpipe -io speaker -- 1.2.3.4 \\\n  | tee output.json\n</code></pre>"},{"location":"examples/#convert-mrt-files-to-json","title":"Convert MRT files to JSON","text":"<p>Stages: read, write</p> <p>Read MRT updates from a compressed file and convert the updates to JSON format. This is particularly useful for analyzing historical BGP data stored in MRT files, which are often used for archiving BGP updates.</p> <pre><code>bgpipe \\\n  -- read updates.20230301.0000.bz2 \\\n  -- write output.json\n</code></pre>"},{"location":"examples/#adding-tcp-md5","title":"Adding TCP-MD5","text":"<p>Stages: listen, connect, stdout</p> <p>Set up a proxy that listens on TCP port 179, waits for a connection, and then proxies it to <code>1.2.3.4</code> with a popular TCP-MD5 password. The conversation is printed to stdout. This setup is useful for \"securing\" BGP sessions, ensuring that only authorized peers can establish a TCP connection. It supports multi-hop scenarios.</p> <pre><code>bgpipe -o \\\n  -- listen :179 \\\n  -- connect --wait listen --md5 solarwinds123 1.2.3.4\n</code></pre>"},{"location":"examples/#stream-mrt-files-to-bgp-routers","title":"Stream MRT files to BGP routers","text":"<p>Stages: speaker, read, listen</p> <p>Listen for new connections on TCP port 179. Configure an active BGP speaker for <code>AS65055</code> that streams a given MRT file when the BGP session is established. This example demonstrates how to replay historical BGP data in a live BGP session, which can be useful for testing and analysis.</p> <pre><code>bgpipe \\\n  -- speaker --active --asn 65055 \\\n  -- read --wait ESTABLISHED updates.20230301.0000.bz2 \\\n  -- listen :179\n</code></pre>"},{"location":"examples/#bgp-sed-in-the-middle-proxy","title":"BGP sed-in-the-middle proxy","text":"<p>Stages: connect, exec</p> <p>Create a BGP proxy that connects <code>1.2.3.4</code> with 85.232.240.179, but rewrites ASNs in their OPEN messages using sed. This is useful for quickly testing and modifying BGP sessions on the fly, allowing you to simulate different network scenarios.</p> <pre><code>bgpipe \\\n  -- connect 1.2.3.4 \\\n  -- exec -LR --args sed -ure '/\"OPEN\"/{ s/65055/65001/g; s/57355/65055/g }' \\\n  -- connect 85.232.240.179\n</code></pre>"},{"location":"examples/#applying-prefix-limits","title":"Applying prefix limits","text":"<p>Stages: connect, limit</p> <p>Filter BGP updates based on prefix lengths and enforce maximum prefix session limits for both IPv4 and IPv6 connections. This helps in managing and securing BGP sessions by limiting the number of prefixes, which can prevent resource exhaustion.</p> <pre><code>bgpipe --kill limit/session \\\n  -- connect 1.2.3.4 \\\n  -- limit -LR --ipv4 --min-length  8 --max-length 24 --session 1000000 \\\n  -- limit -LR --ipv6 --min-length 16 --max-length 48 --session 250000 \\\n  -- connect 5.6.7.8\n</code></pre>"},{"location":"examples/#archive-bgp-sessions-over-encrypted-websockets","title":"Archive BGP sessions over encrypted WebSockets","text":"<p>Stages: connect, websocket</p> <p>Stream the BGP session log in JSON format to a remote WebSocket server for real-time monitoring and archiving. This is useful for integrating BGP session data with external monitoring systems, providing a live feed of BGP activity.</p> <pre><code>bgpipe \\\n  -- connect 1.2.3.4 \\\n  -- websocket -LR --write wss://bgpfix.com/archive?user=demo \\\n  -- connect 85.232.240.179\n</code></pre>"},{"location":"examples/#grep-for-bgp-messages-in-live-sessions","title":"Grep for BGP messages in live sessions","text":"<p>Stages: connect, grep</p> <p>Proxy a connection between two BGP peers, allowing only IPv6 updates from origin AS <code>12345</code>. This is useful for environments that wish to only accept IPv6 prefixes from a specific ASN. The <code>grep</code> stage allows for complex filtering based on various criteria such as message type, prefix, AS_PATH, and more.</p> <pre><code>bgpipe \\\n  -- connect 1.2.3.4 \\\n  -- grep 'ipv6 &amp;&amp; as_origin = 12345' \\\n  -- connect 85.232.240.179\n</code></pre>"},{"location":"examples/#monitor-bgp-prefixes-in-real-time","title":"Monitor BGP prefixes in real-time","text":"<p>Stages: ris-live, grep, stdout</p> <p>Connect to RIPE RIS Live to stream real-time BGP updates from many route collectors, and filter for a specific prefix you're monitoring. RIS Live provides a view of the global BGP routing table without needing your own BGP connections - perfect for network security monitoring, research, and troubleshooting.</p> <pre><code># Monitor all announcements for your network prefix\nbgpipe -g \\\n  -- ris-live \\\n  -- grep 'prefix ~ 1.1.1.0/24' \\\n  -- stdout\n</code></pre>"},{"location":"examples/#stream-live-bgp-with-rpki-filtering","title":"Stream live BGP with RPKI filtering","text":"<p>Stages: ris-live, rpki, update, write</p> <p>Stream RIS Live UPDATEs and validate them against RPKI to detect and filter invalid route announcements in real-time. This combines global visibility with cryptographic validation to protect against BGP hijacking and route leaks. The updates will not be modified on the BGP level (<code>--invalid=keep</code> flag), but will be tagged with <code>rpki/status = INVALID</code>. The <code>update</code> stage is then used to add a community <code>123:456</code> to invalid updates for easy identification. Finally, the stream is saved to a file in JSON format.</p> <pre><code># Real-time BGP monitoring with RPKI validation\nbgpipe -g \\\n  -- ris-live \\\n  -- rpki --invalid=keep \\\n  -- update --if 'tag[rpki/status] = INVALID' --add-com 123:456 \\\n  -- write ris-rpki-updates.json\n</code></pre>"},{"location":"examples/#secure-your-bgp-sessions-with-rpki","title":"Secure your BGP sessions with RPKI","text":"<p>Stages: listen, rpki, connect</p> <p>Add RPKI validation to a BGP proxy between two routers. Invalid prefixes are automatically moved to the withdrawn list (following RFC 7606), preventing propagation of unauthorized route announcements. RPKI uses cryptographic signatures to verify that an AS is authorized to originate a prefix - this protects against both malicious hijacks and configuration errors. The validator connects to Cloudflare's public RTR server by default (or you can use <code>--file</code> to load a local ROA cache).</p> <pre><code># Secure 5.6.7.8 by filtering RPKI-invalid prefixes coming from 1.2.3.4\nbgpipe \\\n  -- listen 1.2.3.4 \\\n  -- rpki \\\n  -- connect 5.6.7.8\n</code></pre>"},{"location":"examples/#strict-rpki-enforcement-mode","title":"Strict RPKI enforcement mode","text":"<p>Stages: listen, rpki, connect</p> <p>Enable strict mode to treat prefixes without any RPKI ROA the same as invalid prefixes. This aggressive stance only allows messages from <code>1.2.3.4</code> clients forwarded to <code>5.6.7.8</code> where all announced prefixes have explicit RPKI authorization, dropping and logging any violations.</p> <pre><code># Drop messages announcing INVALID and/or NOT_FOUND prefixes\nbgpipe --events rpki/dropped \\\n  -- listen 1.2.3.4 \\\n  -- rpki --strict --invalid=drop --event dropped \\\n  -- connect 5.6.7.8\n</code></pre>"},{"location":"examples/#real-time-invalid-route-quarantine","title":"Real-time invalid-route quarantine","text":"<p>Stages: ris-live, rpki, grep, update, write, websocket</p> <p>Tag, quarantine, and mirror only RPKI-invalid announcements in real time. This keeps a clean audit trail for responders while streaming live alerts to a remote monitor.</p> <pre><code>bgpipe -g \\\n  -- ris-live \\\n  -- rpki --invalid keep \\\n  -- grep 'tag[rpki/status] == INVALID' \\\n  -- update --add-com 65000:666 \\\n  -- write invalid-routes.$TIME.json \\\n  -- websocket --write wss://monitor.example.com/bgp\n</code></pre>"},{"location":"examples/#rate-limiting-and-sampling-bgp-streams","title":"Rate limiting and sampling BGP streams","text":"<p>Stages: ris-live, write, listen, connect</p> <p>Protect downstream systems from BGP update storms by rate limiting message flow, or sample high-volume feeds for statistical analysis. The <code>--rate-limit</code> flag delays messages to maintain a maximum rate (messages per second), while <code>--rate-sample</code> randomly samples messages when over the rate threshold, discarding excess messages. This is particularly useful when processing RIS Live feeds or during BGP convergence events.</p> <pre><code># Sample RIS Live at max 100 updates/sec to avoid overwhelming storage\nbgpipe -g \\\n  -- ris-live --rate-sample 100 \\\n  -- write sampled-updates.json\n\n# Rate limit updates from 5.6.7.8 to 50 msg/sec (smooths bursts)\nbgpipe \\\n  -- listen 1.2.3.4 \\\n  -- connect --rate-limit 50 5.6.7.8\n</code></pre>"},{"location":"examples/#exabgp-compatibility","title":"ExaBGP compatibility","text":"<p>Stages: listen, exec, connect, stdin, stdout</p> <p>Use the <code>--format=exa</code> flag to read and write ExaBGP line format instead of JSON. This allows integration with existing ExaBGP-based scripts and tools.</p> <pre><code># Process BGP messages with an ExaBGP-compatible script\nbgpipe \\\n  -- listen 1.2.3.4 \\\n  -- exec --format=exa -LR --args /path/to/script.py \\\n  -- connect 5.6.7.8\n\n# Convert JSON to ExaBGP format\ncat session.json | bgpipe stdin -- stdout --format=exa\n</code></pre>"},{"location":"filters/","title":"Message Filters","text":"<p>Filters let you select BGP messages based on type, prefixes, AS path, origin, MED, LOCAL_PREF, communities, tags, and more. They are used by the <code>grep</code> and <code>drop</code> stages, and by the <code>--if</code> and <code>--of</code> options on any stage.</p> <ul> <li><code>grep FILTER</code> \u2014 keep only matching messages</li> <li><code>drop FILTER</code> \u2014 remove matching messages</li> <li><code>STAGE --if FILTER</code> \u2014 skip stage processing for non-matching messages (input filter)</li> <li><code>STAGE --of FILTER</code> \u2014 drop non-matching stage output (output filter)</li> </ul>"},{"location":"filters/#quick-examples","title":"Quick Examples","text":"<pre><code># keep only IPv6 updates from AS65000\nbgpipe -o read updates.mrt.gz -- grep 'ipv6 &amp;&amp; as_origin == 65000'\n\n# drop non-IPv6 updates where AS_PATH ends with ASN matching 204xxx\nbgpipe -o read updates.mrt.gz -- drop '!ipv6 &amp;&amp; aspath ~ ,204[0-9]+$'\n\n# only for UPDATEs from AS15169, keep those with prefixes overlapping 8.0.0.0/8\nbgpipe -o read updates.mrt.gz -- grep --if 'as_origin == 15169' 'prefix ~ 8.0.0.0/8'\n\n# drop routes with long AS paths or incomplete origin\nbgpipe -o read updates.mrt.gz -- drop 'aspath_len &gt; 10 || origin == incomplete'\n\n# keep only routes with local_pref above default\nbgpipe -o read updates.mrt.gz -- grep 'local_pref &gt; 100'\n</code></pre>"},{"location":"filters/#syntax","title":"Syntax","text":"<p>A filter is one or more expressions chained with <code>&amp;&amp;</code> (AND) and <code>||</code> (OR):</p> <pre><code>[!] attribute[index] [operator value] [&amp;&amp; | ||] ...\n</code></pre> <ul> <li><code>( ... )</code> \u2014 group expressions</li> <li><code>!</code> \u2014 negate an expression</li> <li><code>attribute</code> \u2014 what to test (e.g., <code>prefix</code>, <code>aspath</code>, <code>community</code>)</li> <li><code>[index]</code> \u2014 optional selector within the attribute</li> <li><code>operator value</code> \u2014 comparison; when omitted, tests for attribute existence</li> </ul>"},{"location":"filters/#operators","title":"Operators","text":"Operator Aliases Meaning <code>==</code> <code>=</code> Equal <code>!=</code> <code>=!</code> Not equal <code>&lt;</code> Less than (attribute-specific semantics) <code>&lt;=</code> Less than or equal <code>&gt;</code> Greater than (attribute-specific semantics) <code>&gt;=</code> Greater than or equal <code>~</code> Match (attribute-specific: overlap, regex, containment) <code>!~</code> <code>~!</code> Negative match"},{"location":"filters/#values","title":"Values","text":"<ul> <li>Unquoted tokens: <code>65000</code>, <code>8.0.0.0/8</code>, <code>UPDATE</code></li> <li>Quoted strings: <code>\"65000:100\"</code> (supports <code>\\\\</code> escaping)</li> <li>Numbers: integers, floats, hex (<code>0x...</code>)</li> </ul>"},{"location":"filters/#important-notes","title":"Important Notes","text":"<ul> <li>Most attributes apply to UPDATE messages only. Non-UPDATE messages (OPEN, KEEPALIVE, etc.) evaluate to <code>false</code> for UPDATE-only attributes. Use <code>type</code> conditions for non-UPDATE matching.</li> <li>The <code>~</code> operator uses Go regexp syntax (not shell globs) when matching strings.</li> <li><code>&amp;&amp;</code> and <code>||</code> are evaluated left to right with short-circuit. Use parentheses for explicit grouping when mixing operators: <code>(A &amp;&amp; B) || C</code> instead of <code>A &amp;&amp; B || C</code>.</li> </ul>"},{"location":"filters/#attributes","title":"Attributes","text":""},{"location":"filters/#message-type","title":"Message Type","text":"Attribute Operators Description <code>type</code> <code>==</code>, <code>!=</code> Explicit type comparison: <code>UPDATE</code>, <code>OPEN</code>, <code>KEEPALIVE</code>, <code>NOTIFY</code>, <code>REFRESH</code> <p>Shortcuts (no operator needed):</p> Shortcut Equivalent <code>update</code> <code>type == UPDATE</code> <code>open</code> <code>type == OPEN</code> <code>keepalive</code> <code>type == KEEPALIVE</code> <p>Examples:</p> <pre><code>update                     # match UPDATE messages\nopen || keepalive          # match session control messages\n!update                    # match everything except UPDATEs\ntype == NOTIFY             # match NOTIFICATION messages\n</code></pre>"},{"location":"filters/#address-family","title":"Address Family","text":"Attribute Operators Description <code>af</code> <code>==</code> Address family (AFI/SAFI). Only <code>==</code> is supported. <p>Shortcuts:</p> Shortcut Equivalent <code>ipv4</code> <code>af == IPV4/UNICAST</code> <code>ipv6</code> <code>af == IPV6/UNICAST</code> <p>The <code>af</code> value can match by full AFI/SAFI (e.g., <code>IPV4/UNICAST</code>), by AFI alone (e.g., <code>IPV4</code>), or by SAFI alone (e.g., <code>UNICAST</code>).</p> <p>Examples:</p> <pre><code>ipv4 &amp;&amp; update                   # IPv4 unicast updates\nipv6                             # IPv6 unicast\naf == IPV4/FLOWSPEC              # IPv4 Flowspec\naf == IPV6                       # any IPv6 (unicast, multicast, etc.)\n</code></pre>"},{"location":"filters/#prefixes-nlri","title":"Prefixes (NLRI)","text":"Attribute Operators Description <code>prefix</code> <code>==</code>, <code>~</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> Any prefix (reach or unreach) <code>reach</code> <code>==</code>, <code>~</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> Announced prefixes only <code>unreach</code> <code>==</code>, <code>~</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> Withdrawn prefixes only <p>Prefixes include both classic IPv4 NLRI and MP-BGP (MP_REACH/MP_UNREACH) prefixes.</p> <p>Operator semantics for prefixes:</p> Operator Meaning <code>==</code> Exact match: same address and prefix length <code>~</code> Overlap: message prefix and reference prefix overlap in any way <code>&lt;</code> Message prefix is more specific (longer) than reference, and overlaps <code>&lt;=</code> Message prefix is more specific or equal, and overlaps <code>&gt;</code> Message prefix is less specific (shorter) than reference, and overlaps <code>&gt;=</code> Message prefix is less specific or equal, and overlaps <p>By default, a match succeeds if any prefix in the message matches. Use <code>prefix[*]</code> to require all prefixes to match.</p> <p>Examples:</p> <pre><code>prefix ~ 8.0.0.0/8             # any prefix overlapping 8.0.0.0/8\nreach == 203.0.113.0/24        # exact announcement\nunreach ~ 2001:db8::/32        # any IPv6 withdrawal overlapping 2001:db8::/32\nprefix &lt; 10.0.0.0/8            # more specific than /8 (e.g., 10.1.0.0/16)\nprefix &gt; 10.1.0.0/16           # less specific than /16 (e.g., 10.0.0.0/8)\nprefix[*] ~ 8.0.0.0/8          # ALL prefixes in message overlap 8.0.0.0/8\n</code></pre>"},{"location":"filters/#next-hop","title":"Next-Hop","text":"Attribute Operators Description <code>nexthop</code> <code>==</code>, <code>~</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> Next-hop IP address <code>nh</code> (alias for <code>nexthop</code>) <p>Operator semantics for next-hop:</p> Operator Meaning <code>==</code> Exact IP address match <code>~</code> Next-hop is contained in the given CIDR prefix <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> Numeric IP address comparison <p>Examples:</p> <pre><code>nh == 192.0.2.1                # exact next-hop match\nnexthop ~ 2001:db8::/64        # next-hop within this IPv6 prefix\nnexthop ~ 0.0.0.0/0            # any next-hop (always matches)\n</code></pre>"},{"location":"filters/#as-path","title":"AS Path","text":"Attribute Operators Description <code>aspath</code> <code>==</code>, <code>~</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> Full AS_PATH <code>aspath[N]</code> <code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> Specific hop by index <code>as_origin</code> <code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> Origin AS (last hop, index -1) <code>as_upstream</code> <code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> Upstream of origin (index -2) <code>as_peer</code> <code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> Peer AS (first hop, index 0) <code>aspath_len</code> <code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> AS_PATH length (hop count) <p>Index rules:</p> <ul> <li>Positive: <code>aspath[0]</code> is the first (leftmost) AS, <code>aspath[1]</code> is second, etc.</li> <li>Negative: <code>aspath[-1]</code> is the last (origin) AS, <code>aspath[-2]</code> is the upstream, etc.</li> </ul> <p>Operator semantics:</p> Operator Without index With index (none) AS_PATH exists and is non-empty \u2014 <code>==</code> (int) Any hop equals the value Specific hop equals the value <code>==</code> (string) Full path string matches exactly \u2014 <code>~</code> (regex) Regex match on JSON path text \u2014 <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> Any hop ASN satisfies comparison Specific hop ASN satisfies comparison <p>The <code>~</code> regex matches against the JSON representation of the AS path (comma-separated ASNs without brackets).</p> <p>Examples:</p> <pre><code>as_origin == 15169             # originated by AS15169\nas_peer != 64512               # peer is not AS64512\naspath[1] == 3356              # second hop is AS3356\naspath[-2] == 3356             # upstream of origin is AS3356\naspath ~ \",15169,\"             # AS15169 appears anywhere in the path\naspath ~ \"^15169,\"             # path starts with AS15169\nas_origin &gt; 64511              # origin ASN is in the private range (&gt; 64511)\naspath_len &gt; 5                 # reject long paths\naspath_len == 0                # no AS_PATH (direct peering or incomplete)\n</code></pre>"},{"location":"filters/#origin","title":"Origin","text":"Attribute Operators Description <code>origin</code> <code>==</code>, <code>!=</code> BGP ORIGIN attribute <p>Values: <code>igp</code> (or <code>i</code>, <code>0</code>), <code>egp</code> (or <code>e</code>, <code>1</code>), <code>incomplete</code> (or <code>?</code>, <code>2</code>).</p> <p>Without an operator, tests for the attribute's existence.</p> <p>Examples:</p> <pre><code>origin == igp                  # originated via IGP\norigin != incomplete           # not incomplete origin\norigin                         # has ORIGIN attribute set\n</code></pre>"},{"location":"filters/#med","title":"MED","text":"Attribute Operators Description <code>med</code> <code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> Multi-Exit Discriminator <code>metric</code> (alias for <code>med</code>) <p>Without an operator, tests for the attribute's existence.</p> <p>Examples:</p> <pre><code>med == 0                       # MED is zero\nmed &gt; 100                      # MED above 100\nmed                            # has MED attribute\n</code></pre>"},{"location":"filters/#local_pref","title":"LOCAL_PREF","text":"Attribute Operators Description <code>local_pref</code> <code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> LOCAL_PREF value <code>localpref</code> (alias for <code>local_pref</code>) <p>Without an operator, tests for the attribute's existence.</p> <p>Examples:</p> <pre><code>local_pref == 100              # default local preference\nlocal_pref &gt; 100               # preferred routes\nlocalpref &lt;= 50                # low-preference routes\n</code></pre>"},{"location":"filters/#communities","title":"Communities","text":"Attribute Operators Description <code>community</code>, <code>com</code> <code>==</code>, <code>~</code> Standard communities <code>ext_community</code>, <code>ext_com</code>, <code>com_ext</code> <code>==</code>, <code>~</code> Extended communities <code>large_community</code>, <code>large_com</code>, <code>com_large</code> <code>==</code>, <code>~</code> Large communities <p>Operator semantics:</p> Operator Meaning (none) Community attribute exists (has any value) <code>==</code> Message has an exact community value <code>~</code> Regex match against JSON text of all communities <p>The <code>~</code> regex matches against the JSON representation. For standard communities, this is <code>\"ASN:VALUE\"</code> strings. For extended communities, the JSON contains the full structure with type names like <code>TARGET</code>, <code>IP4_TARGET</code>, etc. (see JSON Format).</p> <p>Examples:</p> <pre><code>community                      # has any standard community\ncommunity == \"3356:100\"        # has exact community 3356:100\ncommunity ~ \"3356:\"            # any community with ASN 3356\ncom_large ~ \"1234:5678:9\"      # large community matching pattern\next_community ~ \"TARGET\"       # has any Route Target extended community\n</code></pre>"},{"location":"filters/#tags","title":"Tags","text":"Attribute Operators Description <code>tag</code>, <code>tags</code> <code>==</code>, <code>~</code> Pipeline metadata tags <code>tag[KEY]</code> <code>==</code>, <code>~</code> Specific tag by key name <p>Tags are key-value pairs attached to messages by the <code>tag</code> stage and other stages (e.g., <code>ris-live</code> adds <code>PEER_AS</code>, <code>PEER_IP</code>; <code>rpki</code> adds <code>rpki/status</code>).</p> <p>Tag filters work on all message types (not just UPDATEs).</p> Operator Without index With <code>[KEY]</code> (none) Any tag has a non-empty value Tag KEY has a non-empty value <code>==</code> Any tag value equals the string Tag KEY equals the string <code>~</code> Any tag value matches the regex Tag KEY matches the regex <p>Examples:</p> <pre><code>tag[rpki/status] == INVALID    # RPKI validation failed\ntag[PEER_AS] == \"8218\"         # from RIS peer AS8218\ntags[region] ~ \"^eu-\"          # region tag starts with \"eu-\"\n</code></pre>"},{"location":"filters/#operator-compatibility","title":"Operator Compatibility","text":"<p>Not all operators work with all attributes. This table summarizes:</p> Attribute (exists) <code>==</code> <code>!=</code> <code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code> <code>~</code> <code>!~</code> <code>type</code> yes yes <code>af</code> yes <code>prefix</code> yes yes yes yes (specificity) yes (overlap) <code>nexthop</code> yes yes yes yes (numeric IP) yes (containment) <code>aspath</code> yes yes yes yes (ASN value) yes (regex) <code>aspath_len</code> yes yes yes yes (hop count) <code>origin</code> yes yes yes <code>med</code> yes yes yes yes (uint32) <code>local_pref</code> yes yes yes yes (uint32) <code>community</code> yes yes yes yes (regex) <code>ext_community</code> yes yes yes yes (regex) <code>large_community</code> yes yes yes yes (regex) <code>tag</code> yes yes yes yes (regex)"},{"location":"filters/#see-also","title":"See Also","text":"<ul> <li>grep / drop \u2014 Stages that use filters</li> <li>JSON Format \u2014 BGP message JSON structure (community <code>~</code> matches against this)</li> <li>Examples \u2014 Practical bgpipe pipelines</li> </ul>"},{"location":"flowspec/","title":"Flowspec JSON Format","text":"<p>Flowspec (Flow Specification, RFC 8955) carries traffic filtering policies over BGP. A Flowspec UPDATE message consists of two parts:</p> <ul> <li>Rules \u2014 traffic match conditions, carried in <code>MP_REACH</code> (or <code>MP_UNREACH</code> for withdrawals)</li> <li>Actions \u2014 what to do with matched traffic, carried in <code>EXT_COMMUNITY</code></li> </ul>"},{"location":"flowspec/#complete-example","title":"Complete Example","text":"<p>Block all TCP port 80 traffic to 192.0.2.0/24:</p> <pre><code>[\n  \"R\", 15, \"2025-07-11T10:50:00.000\", \"UPDATE\",\n  {\n    \"attrs\": {\n      \"ORIGIN\": {\"flags\": \"T\", \"value\": \"IGP\"},\n      \"ASPATH\": {\"flags\": \"T\", \"value\": [65055]},\n      \"MP_REACH\": {\n        \"flags\": \"OX\",\n        \"value\": {\n          \"af\": \"IPV4/FLOWSPEC\",\n          \"rules\": [\n            {\n              \"DST\": \"192.0.2.0/24\",\n              \"PROTO\": [{\"op\": \"==\", \"val\": 6}],\n              \"PORT_DST\": [{\"op\": \"==\", \"val\": 80}]\n            }\n          ]\n        }\n      },\n      \"EXT_COMMUNITY\": {\n        \"flags\": \"OT\",\n        \"value\": [\n          {\"type\": \"FLOW_RATE_BYTES\", \"value\": 0}\n        ]\n      }\n    }\n  },\n  null\n]\n</code></pre> <p>The rule in <code>MP_REACH</code> matches TCP (protocol 6) traffic to port 80 destined for 192.0.2.0/24. The action in <code>EXT_COMMUNITY</code> rate-limits matching traffic to 0 bytes/sec (i.e., drops it).</p>"},{"location":"flowspec/#flowspec-rules","title":"Flowspec Rules","text":"<p>Rules are carried in the <code>MP_REACH</code> attribute with a Flowspec address family (<code>IPV4/FLOWSPEC</code> or <code>IPV6/FLOWSPEC</code>). Each rule is a JSON object mapping component names to match conditions:</p> <pre><code>\"MP_REACH\": {\n  \"flags\": \"OX\",\n  \"value\": {\n    \"af\": \"IPV4/FLOWSPEC\",\n    \"rules\": [\n      {\n        \"DST\": \"192.0.2.0/24\",\n        \"SRC\": \"198.51.100.0/24\",\n        \"PROTO\": [{\"op\": \"==\", \"val\": 6}],\n        \"PORT_DST\": [{\"op\": \"==\", \"val\": 80}]\n      }\n    ]\n  }\n}\n</code></pre> <p>Withdrawals use <code>MP_UNREACH</code> with the same structure (without <code>nexthop</code>).</p>"},{"location":"flowspec/#components","title":"Components","text":"Component Type Description <code>DST</code> prefix Destination IP prefix <code>SRC</code> prefix Source IP prefix <code>PROTO</code> numeric IP protocol number (6 = TCP, 17 = UDP) <code>PORT</code> numeric Source or destination port <code>PORT_DST</code> numeric Destination port <code>PORT_SRC</code> numeric Source port <code>ICMP_TYPE</code> numeric ICMP type <code>ICMP_CODE</code> numeric ICMP code <code>TCP_FLAGS</code> bitmask TCP flags <code>PKTLEN</code> numeric IP packet length <code>DSCP</code> numeric DSCP value <code>FRAG</code> bitmask IP fragmentation flags <code>LABEL</code> numeric IPv6 flow label (IPv6 Flowspec only) <p>The Type column indicates which operator format the component uses: see Numeric Operators or Bitmask Operators below.</p>"},{"location":"flowspec/#ipv6-prefix-with-offset","title":"IPv6 Prefix with Offset","text":"<p>IPv6 Flowspec prefixes can include a bit offset:</p> <pre><code>\"DST\": \"2001:db8::/32/0-32\"\n</code></pre> <p>Format: <code>address/length/offset-length</code> where offset is the bit position to start matching from.</p>"},{"location":"flowspec/#numeric-operators","title":"Numeric Operators","text":"<p>Components of the numeric type (<code>PROTO</code>, <code>PORT</code>, <code>PORT_DST</code>, <code>PORT_SRC</code>, <code>ICMP_TYPE</code>, <code>ICMP_CODE</code>, <code>PKTLEN</code>, <code>DSCP</code>, <code>LABEL</code>) use arrays of operator objects:</p> <pre><code>\"PORT_DST\": [\n  {\"and\": true, \"op\": \"&gt;=\", \"val\": 8000},\n  {\"op\": \"&lt;=\", \"val\": 9000}\n]\n</code></pre> <p>This matches destination ports 8000-9000: the first condition matches &gt;= 8000 and is ANDed with the next condition (&lt;= 9000).</p> Field Type Description <code>op</code> string Comparison operator (see Numeric Operator Values) <code>val</code> integer Value to compare against <code>and</code> boolean If <code>true</code>, AND the result of this condition with the next one. Default: OR with the next condition. <p>Multiple conditions in the array are combined with OR by default. Set <code>\"and\": true</code> on a condition to AND it with the following condition instead.</p>"},{"location":"flowspec/#numeric-operator-values","title":"Numeric Operator Values","text":"Operator Meaning <code>==</code> Equal <code>!=</code> Not equal <code>&gt;</code> Greater than <code>&gt;=</code> Greater than or equal <code>&lt;</code> Less than <code>&lt;=</code> Less than or equal <code>true</code> Always match <code>false</code> Never match"},{"location":"flowspec/#bitmask-operators","title":"Bitmask Operators","text":"<p>Components of the bitmask type (<code>TCP_FLAGS</code>, <code>FRAG</code>) use arrays of bitmask operator objects:</p> <pre><code>\"TCP_FLAGS\": [\n  {\"op\": \"ALL\", \"val\": \"0x02\"}\n]\n</code></pre> <p>This matches packets with the SYN flag set.</p> Field Type Description <code>op</code> string Bitmask operation (see Bitmask Operation Values) <code>val</code> string Hex bitmask (e.g., <code>\"0x02\"</code>) <code>len</code> integer Value length in bytes (1, 2, 4, 8) <code>and</code> boolean If <code>true</code>, AND the result of this condition with the next one. Default: OR with the next condition."},{"location":"flowspec/#bitmask-operation-values","title":"Bitmask Operation Values","text":"Operation Meaning <code>ANY</code> Match if any specified bit set <code>ALL</code> Match if all specified bits set <code>NONE</code> Match if no specified bits set <code>NOT-ALL</code> Match if not all bits set"},{"location":"flowspec/#flowspec-actions","title":"Flowspec Actions","text":"<p>Actions define what happens to traffic matching the Flowspec rules. They are encoded as extended communities in the <code>EXT_COMMUNITY</code> attribute of the same UPDATE message.</p> Action Extended community type Value Description Drop traffic <code>FLOW_RATE_BYTES</code> <code>0</code> Rate-limit to 0 bytes/sec Rate-limit <code>FLOW_RATE_BYTES</code> <code>1500.5</code> or <code>\"id:rate\"</code> Limit bytes/sec Rate-limit (packets) <code>FLOW_RATE_PACKETS</code> <code>100</code> or <code>\"id:rate\"</code> Limit packets/sec Traffic action <code>FLOW_ACTION</code> <code>{\"terminal\": bool, \"sample\": bool}</code> Terminal/sample flags Redirect (2-byte ASN) <code>FLOW_REDIRECT_AS2</code> <code>\"ASN:value\"</code> Redirect to VRF Redirect (IPv4) <code>FLOW_REDIRECT_IP4</code> <code>\"IP:value\"</code> Redirect to VRF (IP-based) Redirect (4-byte ASN) <code>FLOW_REDIRECT_AS4</code> <code>\"ASN:value\"</code> Redirect to VRF (4-byte ASN) Redirect to next-hop <code>FLOW_REDIRECT_NH</code> <code>{\"copy\": bool}</code> Redirect via next-hop DSCP marking <code>FLOW_DSCP</code> integer Set DSCP value"},{"location":"flowspec/#example-rate-limit-with-redirect","title":"Example: Rate-limit with Redirect","text":"<p>Rate-limit UDP traffic from 198.51.100.0/24 to 10 Mbps and redirect to VRF:</p> <pre><code>\"EXT_COMMUNITY\": {\n  \"flags\": \"OT\",\n  \"value\": [\n    {\"type\": \"FLOW_RATE_BYTES\", \"value\": 1250000},\n    {\"type\": \"FLOW_REDIRECT_AS2\", \"value\": \"65055:100\"}\n  ]\n}\n</code></pre>"},{"location":"flowspec/#see-also","title":"See Also","text":"<ul> <li>JSON Format \u2014 General BGP message JSON format</li> <li>Message Filters \u2014 Filter BGP messages</li> <li>bgpfix library \u2014 The underlying Go library</li> </ul>"},{"location":"intro/","title":"Introduction","text":"<p>The tools available today for working with BGP are fundamentally passive. BMP streams a copy of the RIB to a collector. MRT dumps give you a snapshot you can analyze after the fact. CLI scraping lets you poll a router's state. All of these let you observe \u2014 but none of them let you act.</p> <p>When a route leak propagates, when a hijacked prefix slips through filters, when a peer floods you with deaggregated /48s \u2014 the response is manual: log in, type commands, hope the vendor's filtering syntax does what you think it does. There is no standard, programmable layer between BGP speakers where you can inspect, filter, and transform messages in real time.</p> <p>bgpipe fills that gap. It operates as a transparent proxy sitting on the BGP wire between two speakers. Every message flowing in either direction passes through a pipeline of composable stages \u2014 each doing one thing well, chained together like UNIX pipes:</p> <pre><code>router A  \u2500\u2500\u25b6  [ listen \u2500\u2500 grep \u2500\u2500 rpki \u2500\u2500 limit \u2500\u2500 connect ]  \u2500\u2500\u25b6  router B\n</code></pre> <p>Stages can filter messages (<code>grep</code>, <code>drop</code>), enforce policy (<code>limit</code>, <code>rpki</code>), transform data (<code>update</code>, <code>tag</code>), bridge formats (<code>read</code>, <code>write</code>, <code>stdin</code>, <code>stdout</code>), connect to external systems (<code>exec</code>, <code>pipe</code>, <code>websocket</code>), or tap into live data feeds (<code>ris-live</code>, <code>rv-live</code>).</p> <p>Because bgpipe speaks native BGP on both sides, routers see a normal peer \u2014 no protocol changes, no vendor lock-in. Because every message has a full JSON representation (including Flowspec), you can pipe BGP through <code>jq</code>, Python, or any tool that handles JSON. Because it supports MRT, BMP, and ExaBGP formats, it integrates with existing infrastructure.</p> <p>The result is a single tool that handles monitoring, filtering, security enforcement, format conversion, and session manipulation \u2014 all from the command line, all composable, all scriptable.</p> <p>See the quickstart guide for a practical introduction. You can also watch the RIPE 88 bgpipe talk below.</p> <p>The talk was summarized in June 2024 by Geoff Huston on the APNIC blog as follows:</p> <p>Observing and measuring the dynamic behaviour of BGP has used a small set of tools for quite some time. There\u2019s the BGP Monitoring Protocol (BMP, RFC 7854), there\u2019s the Multi-threaded Routing Toolkit (MRT) for BGP snapshot and update logs, and if you really want to head back to the earliest days of this work, there are scripts to interrogate a router via the command-line interface, CLI. All of these are observation tools, but they cannot alter the BGP messages that are being passed between BGP speakers.</p> <p>The bgpipe tool, presented by Pawe\u0142 Foremski, is an interesting tool that operates both as a BGP \u2018wire sniffer\u2019 but also allows BGP messages to be altered on the fly (Figure 1).</p> <p></p> <p>Internally, the bgpipe process can be configured to invoke supplied \u2018callback\u2019 routines when part of a BGP message matches some provided pattern, such as a particular IP prefix, update attribute patterns or such, and it can also be configured to have \u2018events\u2019 which processing elements in bgpipe can subscribe to. Simple use cases are to take a BGP session and produce a JSON-formatted log of all BGP messages or take an unencrypted BGP session and add TCP-MD5 encryption. More advanced cases can make use of an external call interface to add route validation checks using RPKI credentials.</p> <p>There has been some concern about using IPv6 prefixes to perform a BGP more specific route flooding attack and its possible to use a bgpipe module to perform various forms of prefix thresholds (per origin Autonomous System (AS) or per aggregate prefix) to detect and filter out the effects of such flooding attacks.</p> <p>It\u2019s early days in this work, but it is certainly an intriguing and novel BGP tool.</p>"},{"location":"json-format/","title":"JSON Message Format","text":"<p>bgpipe can read and write BGP messages in a structured JSON format for processing, filtering, and archiving. This page is a reference for the format, implemented by the bgpfix library.</p>"},{"location":"json-format/#message-envelope","title":"Message Envelope","text":"<p>Each BGP message is a JSON array with up to 6 elements:</p> <pre><code>[\"R\", 243, \"2025-07-11T11:23:50.860\", \"UPDATE\", {...}, {...}]\n</code></pre> Index Name Type Description <code>[0]</code> <code>dir</code> string Direction: <code>\"L\"</code> (left-bound) or <code>\"R\"</code> (right-bound) <code>[1]</code> <code>seq</code> integer Monotonically increasing sequence number <code>[2]</code> <code>time</code> string Timestamp: <code>YYYY-MM-DDTHH:MM:SS.mmm</code> <code>[3]</code> <code>type</code> string Message type (see table below) <code>[4]</code> <code>data</code> object/string/null Type-specific payload (see below) <code>[5]</code> <code>meta</code> object/null Message tags (key-value map)"},{"location":"json-format/#message-types","title":"Message Types","text":"Type <code>data</code> field contains <code>OPEN</code> BGP session parameters and capabilities (object) <code>UPDATE</code> Prefixes and path attributes (object) <code>KEEPALIVE</code> <code>null</code> <p>Unknown or unparsed types produce a hex string like <code>\"0x1234abcd\"</code>.</p>"},{"location":"json-format/#example","title":"Example","text":"<p>KEEPALIVE \u2014 the simplest message: <pre><code>[\"R\", 2, \"2025-07-11T08:47:22.659\", \"KEEPALIVE\"]\n</code></pre></p>"},{"location":"json-format/#open-messages","title":"OPEN Messages","text":"<p>The <code>data</code> field contains BGP session parameters:</p> <pre><code>{\n  \"bgp\": 4,\n  \"asn\": 65055,\n  \"id\": \"85.232.240.180\",\n  \"hold\": 7200,\n  \"caps\": { ... }\n}\n</code></pre> Field Type Description <code>bgp</code> integer BGP protocol version (always <code>4</code>) <code>asn</code> integer Autonomous System Number (2-byte in OPEN, see <code>AS4</code> cap) <code>id</code> string BGP Router ID in dotted-decimal notation <code>hold</code> integer Hold time in seconds <code>caps</code> object BGP capabilities (see below) <code>params</code> string Raw optional parameters as hex (only when no capabilities)"},{"location":"json-format/#capabilities","title":"Capabilities","text":"<p>The <code>caps</code> object maps capability names to their values:</p> <pre><code>{\n  \"MP\": [\"IPV4/UNICAST\", \"IPV6/UNICAST\", \"IPV4/FLOWSPEC\"],\n  \"ROUTE_REFRESH\": true,\n  \"EXTENDED_MESSAGE\": true,\n  \"AS4\": 65055,\n  \"ADDPATH\": [\"IPV4/UNICAST/SEND\", \"IPV6/UNICAST/BIDIR\"],\n  \"ROLE\": \"CUSTOMER\",\n  \"FQDN\": {\"host\": \"router1\", \"domain\": \"example.com\"},\n  \"EXTENDED_NEXTHOP\": [\"IPV4/UNICAST/IPV6\"]\n}\n</code></pre> Capability Value type Description <code>MP</code> array of strings Multi-protocol AFI/SAFI list (RFC 4760) <code>ROUTE_REFRESH</code> <code>true</code> Route Refresh support (RFC 2918) <code>EXTENDED_MESSAGE</code> <code>true</code> Extended message support (RFC 8654) <code>AS4</code> integer 4-byte ASN (RFC 6793) <code>ADDPATH</code> array of strings ADD-PATH directions (RFC 7911): <code>AFI/SAFI/DIR</code> where DIR is <code>RECEIVE</code>, <code>SEND</code>, or <code>BIDIR</code> <code>ROLE</code> string BGP Role (RFC 9234): <code>PROVIDER</code>, <code>RS</code>, <code>RS-CLIENT</code>, <code>CUSTOMER</code>, or <code>PEER</code> <code>FQDN</code> object Hostname capability (draft): <code>{\"host\": \"...\", \"domain\": \"...\"}</code> <code>EXTENDED_NEXTHOP</code> array of strings Extended next-hop (RFC 8950): <code>AFI/SAFI/NH_AFI</code> <code>GRACEFUL_RESTART</code> (presence/value) Graceful Restart (RFC 4724) <code>ENHANCED_ROUTE_REFRESH</code> <code>true</code> Enhanced Route Refresh (RFC 7313) <code>LLGR</code> (presence/value) Long-Lived Graceful Restart <code>PRE_ROUTE_REFRESH</code> <code>true</code> Pre-standard Route Refresh (code 128) <p>Unknown capabilities appear as <code>\"CAP_N\"</code> with a hex string value.</p> <p>AFI/SAFI strings use the format <code>AFI/SAFI</code>, e.g.: <code>IPV4/UNICAST</code>, <code>IPV6/UNICAST</code>, <code>IPV4/MULTICAST</code>, <code>IPV6/MULTICAST</code>, <code>IPV4/FLOWSPEC</code>, <code>IPV6/FLOWSPEC</code>, <code>IPV4/MPLS_VPN</code>, etc.</p>"},{"location":"json-format/#complete-open-example","title":"Complete OPEN Example","text":"<pre><code>[\n  \"L\", 1, \"2025-07-11T08:47:22.659\", \"OPEN\",\n  {\n    \"bgp\": 4,\n    \"asn\": 65055,\n    \"id\": \"85.232.240.180\",\n    \"hold\": 7200,\n    \"caps\": {\n      \"MP\": [\"IPV4/FLOWSPEC\"],\n      \"ROUTE_REFRESH\": true,\n      \"EXTENDED_NEXTHOP\": [\"IPV4/UNICAST/IPV6\", \"IPV4/MULTICAST/IPV6\"],\n      \"AS4\": 65055,\n      \"PRE_ROUTE_REFRESH\": true\n    }\n  },\n  null\n]\n</code></pre>"},{"location":"json-format/#update-messages","title":"UPDATE Messages","text":"<p>The <code>data</code> field contains prefixes and path attributes:</p> <pre><code>{\n  \"reach\": [\"8.8.8.0/24\", \"8.8.4.0/24\"],\n  \"unreach\": [\"192.0.2.0/24\"],\n  \"attrs\": { ... }\n}\n</code></pre> Field Type Description <code>reach</code> array Announced IPv4 unicast prefixes (CIDR notation) <code>unreach</code> array Withdrawn IPv4 unicast prefixes (CIDR notation) <code>attrs</code> object Path attributes (see below) <p>For multi-protocol routes (IPv6, Flowspec, etc.), prefixes are in the <code>MP_REACH</code> and <code>MP_UNREACH</code> attributes instead.</p>"},{"location":"json-format/#add-path","title":"ADD-PATH","text":"<p>When ADD-PATH (RFC 7911) is negotiated, each prefix carries a 32-bit Path Identifier. In JSON, the path ID is prepended to the prefix string with <code>#</code> delimiters:</p> <pre><code>\"reach\": [\"#42#8.8.8.0/24\", \"#42#8.8.4.0/24\"]\n</code></pre> <p>The format is <code>#&lt;path-id&gt;#&lt;prefix&gt;</code>. Without ADD-PATH, prefixes appear as plain CIDR strings.</p>"},{"location":"json-format/#path-attributes","title":"Path Attributes","text":"<p>Each attribute in <code>attrs</code> is an object with <code>flags</code> and <code>value</code>:</p> <pre><code>\"ORIGIN\": {\n  \"flags\": \"T\",\n  \"value\": \"IGP\"\n}\n</code></pre> <p>Flags are a string of characters:</p> Flag Meaning <code>O</code> Optional <code>T</code> Transitive <code>P</code> Partial <code>X</code> Extended length"},{"location":"json-format/#attribute-reference","title":"Attribute Reference","text":"Attribute Flags Value format Description <code>ORIGIN</code> <code>T</code> <code>\"IGP\"</code>, <code>\"EGP\"</code>, or <code>\"INCOMPLETE\"</code> Route origin (RFC 4271) <code>ASPATH</code> <code>T</code> array of integers / nested arrays AS path (see below) <code>NEXTHOP</code> <code>T</code> <code>\"192.0.2.1\"</code> IPv4 next-hop address <code>MED</code> <code>O</code> integer Multi-Exit Discriminator <code>LOCALPREF</code> <code>T</code> integer Local Preference <code>AGGREGATE</code> <code>T</code> (empty/presence) Atomic Aggregate marker <code>AGGREGATOR</code> <code>OT</code> <code>{\"asn\": N, \"addr\": \"IP\"}</code> Aggregator (RFC 4271) <code>COMMUNITY</code> <code>OT</code> <code>[\"65000:100\", \"65000:200\"]</code> Standard communities (RFC 1997) <code>ORIGINATOR</code> <code>O</code> <code>\"192.0.2.1\"</code> Route Reflector originator <code>CLUSTER_LIST</code> <code>O</code> <code>[\"192.0.2.1\", \"192.0.2.2\"]</code> Route Reflector cluster list <code>MP_REACH</code> <code>OX</code> object (see MP-BGP section) Multi-protocol NLRI <code>MP_UNREACH</code> <code>OX</code> object (see MP-BGP section) Multi-protocol withdrawals <code>EXT_COMMUNITY</code> <code>OT</code> array of objects (see below) Extended communities (RFC 4360) <code>AS4PATH</code> <code>OT</code> same format as <code>ASPATH</code> 4-byte AS path (RFC 6793) <code>AS4AGGREGATOR</code> <code>OT</code> same format as <code>AGGREGATOR</code> 4-byte Aggregator (RFC 6793) <code>OTC</code> <code>OT</code> integer Only-To-Customer (RFC 9234) <code>LARGE_COMMUNITY</code> <code>OT</code> <code>[\"65000:100:1\", \"65000:200:2\"]</code> Large communities (RFC 8092) <p>Unrecognized attributes appear as <code>ATTR_N</code> with a hex string value.</p>"},{"location":"json-format/#aspath","title":"ASPATH","text":"<p>AS_SEQUENCE segments are flat; AS_SET segments are nested arrays:</p> <pre><code>\"ASPATH\": {\"flags\": \"T\", \"value\": [64515, 20473, 15169]}\n</code></pre> <p>With an AS_SET:</p> <pre><code>\"ASPATH\": {\"flags\": \"T\", \"value\": [64515, [20473, 15169]]}\n</code></pre> <p>The AS_SET <code>[20473, 15169]</code> is a single hop containing multiple ASNs. AS_CONFED_SEQUENCE and AS_CONFED_SET use the same representation (flat/nested) with no distinct marker.</p>"},{"location":"json-format/#communities","title":"Communities","text":"<p>Standard (<code>COMMUNITY</code>) \u2014 array of <code>\"ASN:VALUE\"</code> strings (both uint16):</p> <pre><code>\"COMMUNITY\": {\"flags\": \"OT\", \"value\": [\"64515:100\", \"8218:20000\"]}\n</code></pre> <p>Large (<code>LARGE_COMMUNITY</code>) \u2014 array of <code>\"ASN:VALUE1:VALUE2\"</code> strings (all uint32):</p> <pre><code>\"LARGE_COMMUNITY\": {\"flags\": \"OT\", \"value\": [\"20473:300:15169\"]}\n</code></pre> <p>Extended (<code>EXT_COMMUNITY</code>) \u2014 array of objects with <code>type</code>, <code>value</code>, and optional <code>nontransitive</code>:</p> <pre><code>\"EXT_COMMUNITY\": {\n  \"flags\": \"OT\",\n  \"value\": [\n    {\"type\": \"TARGET\", \"value\": \"65000:100\"},\n    {\"type\": \"IP4_TARGET\", \"value\": \"192.0.2.1:100\"},\n    {\"type\": \"AS4_TARGET\", \"value\": \"65000:100\"},\n    {\"type\": \"ORIGIN\", \"value\": \"65000:200\"}\n  ]\n}\n</code></pre> <p>Extended community type names:</p> Type name Description Value format <code>TARGET</code> Route Target (2-byte ASN) <code>\"ASN:value\"</code> <code>ORIGIN</code> Route Origin (2-byte ASN) <code>\"ASN:value\"</code> <code>IP4_TARGET</code> Route Target (IPv4) <code>\"IP:value\"</code> <code>IP4_ORIGIN</code> Route Origin (IPv4) <code>\"IP:value\"</code> <code>AS4_TARGET</code> Route Target (4-byte ASN) <code>\"ASN:value\"</code> <code>AS4_ORIGIN</code> Route Origin (4-byte ASN) <code>\"ASN:value\"</code> <p>Unknown types appear as <code>\"0xNNNN\"</code>. The <code>\"nontransitive\": true</code> field is added when the community is non-transitive across ASes.</p> <p>For Flowspec-specific extended community types (<code>FLOW_RATE_BYTES</code>, <code>FLOW_REDIRECT_AS2</code>, etc.), see Flowspec.</p>"},{"location":"json-format/#mp-bgp-multi-protocol","title":"MP-BGP (Multi-Protocol)","text":""},{"location":"json-format/#mp_reach","title":"MP_REACH","text":"<p>For IPv6 and other multi-protocol reachable NLRI:</p> <pre><code>\"MP_REACH\": {\n  \"flags\": \"OX\",\n  \"value\": {\n    \"af\": \"IPV6/UNICAST\",\n    \"nexthop\": \"2001:db8::1\",\n    \"prefixes\": [\"2001:db8:1::/48\", \"2001:db8:2::/48\"]\n  }\n}\n</code></pre> Field Type Description <code>af</code> string Address family: <code>\"AFI/SAFI\"</code> <code>nexthop</code> string Next-hop address (omitted when unspecified) <code>link-local</code> string IPv6 link-local next-hop (optional, IPv6 only) <code>prefixes</code> array Prefix strings in CIDR notation <p>For Flowspec address families, the format uses <code>rules</code> instead of <code>prefixes</code> \u2014 see Flowspec.</p> <p>When the NLRI is not parsed (unsupported address family), the value falls back to:</p> <pre><code>{\"af\": \"AFI/SAFI\", \"nh\": \"0x...\", \"data\": \"0x...\"}\n</code></pre>"},{"location":"json-format/#mp_unreach","title":"MP_UNREACH","text":"<p>Same structure without <code>nexthop</code>:</p> <pre><code>\"MP_UNREACH\": {\n  \"flags\": \"OX\",\n  \"value\": {\n    \"af\": \"IPV6/UNICAST\",\n    \"prefixes\": [\"2001:db8:3::/48\"]\n  }\n}\n</code></pre>"},{"location":"json-format/#complete-update-example","title":"Complete UPDATE Example","text":"<pre><code>[\n  \"R\", 243, \"2025-07-11T11:23:50.860\", \"UPDATE\",\n  {\n    \"reach\": [\"8.8.8.0/24\", \"8.8.4.0/24\"],\n    \"attrs\": {\n      \"ORIGIN\": {\"flags\": \"T\", \"value\": \"IGP\"},\n      \"ASPATH\": {\"flags\": \"T\", \"value\": [64515, 15169]},\n      \"NEXTHOP\": {\"flags\": \"T\", \"value\": \"192.0.2.1\"},\n      \"COMMUNITY\": {\"flags\": \"OT\", \"value\": [\"64515:100\"]},\n      \"OTC\": {\"flags\": \"OTP\", \"value\": 6777}\n    }\n  },\n  {\"PEER_AS\": \"8218\", \"PEER_IP\": \"5.57.80.210\"}\n]\n</code></pre>"},{"location":"json-format/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>Hex fallback: Unparsed upper layers and attributes appear as hex strings like <code>\"0x1234abcd\"</code>.</li> <li>Bidirectional: The format fully supports both encoding (JSON to BGP wire) and decoding (BGP wire to JSON).</li> <li>Timestamps: Millisecond precision, format <code>YYYY-MM-DDTHH:MM:SS.mmm</code>.</li> <li>Prefixes: Standard CIDR notation (<code>192.0.2.0/24</code>, <code>2001:db8::/32</code>).</li> <li>Metadata (<code>[5]</code>): Contains pipeline tags (e.g., from the <code>tag</code> stage, <code>ris-live</code> peer info, <code>rpki</code> validation status). Can be <code>null</code> when no metadata is attached.</li> </ul>"},{"location":"json-format/#see-also","title":"See Also","text":"<ul> <li>Flowspec Format \u2014 Flowspec rules and actions in JSON</li> <li>Message Filters \u2014 Filter BGP messages using <code>grep</code> and <code>drop</code> stages</li> <li>Examples \u2014 Practical bgpipe command-line examples</li> <li>bgpfix library \u2014 The underlying Go library</li> </ul>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#installation","title":"Installation","text":"<p>To get started with <code>bgpipe</code>, you need to install it on your system, ie. where you want it to proxy or terminate BGP sessions. <code>bgpipe</code> is a single binary that can be run on any machine, preferably Linux. It does not require any additional libraries or dependencies, making it easy to deploy - just copy the binary to your target machine.</p> <p>You can download pre-built binaries from the GitHub Releases page.</p> <p>Alternatively, you can compile from source. You need to have Go installed first. Then, you can run:</p> <pre><code>go install github.com/bgpfix/bgpipe@latest   # note (1)\n</code></pre> <ol> <li>Make sure to put the resultant <code>bgpipe</code> binary in your <code>$PATH</code>. Go installs executables in the directory named by the <code>$GOBIN</code> environment variable, which defaults to <code>$GOPATH/bin</code>, or <code>$HOME/go/bin</code> if the <code>$GOPATH</code> variable is not set.</li> </ol>"},{"location":"quickstart/#running-bgpipe","title":"Running bgpipe","text":"<p>When you run <code>bgpipe</code> without any arguments, it will print the help message, for example:</p> <pre><code>Usage: bgpipe [OPTIONS] [--] STAGE1 [OPTIONS] [ARGUMENTS] [--] STAGE2...\n\nOptions:\n  -v, --version          print detailed version info and quit\n  -n, --explain          print the pipeline as configured and quit\n  -l, --log string       log level (debug/info/warn/error/disabled) (default \"info\")\n      --pprof string     bind pprof to given listen address\n  -e, --events strings   log given events (\"all\" means all events) (default [PARSE,ESTABLISHED,EOR])\n  -k, --kill strings     kill session on any of these events\n  -i, --stdin            read JSON from stdin\n  -o, --stdout           write JSON to stdout\n  -I, --stdin-wait       like --stdin but wait for EVENT_ESTABLISHED\n  -O, --stdout-wait      like --stdout but wait for EVENT_EOR\n  -2, --short-asn        force 2-byte AS numbers\n  -g, --guess-asn        guess AS number byte size\n      --caps string      use given BGP capabilities (JSON format)\n\nSupported stages (run &lt;stage&gt; -h to get its help)\n  connect                connect to a BGP endpoint over TCP\n  drop                   drop messages that match a filter\n  exec                   handle messages in a background process\n  grep                   drop messages that DO NOT match a filter\n  head                   stop pipeline after N messages\n  limit                  limit prefix lengths and counts\n  listen                 let a BGP client connect over TCP\n  pipe                   process messages through a named pipe\n  read                   read messages from file or URL\n  ris-live               read BGP updates from RIPE RIS Live\n  rpki                   validate UPDATEs using RPKI\n  rv-live                read BGP updates from RouteViews.org via Kafka\n  speaker                run a simple BGP speaker\n  stdin                  read messages from stdin\n  stdout                 print messages to stdout\n  tag                    add or drop message tags\n  update                 modify UPDATE messages\n  websocket              process messages over websocket\n  write                  write messages to file\n</code></pre> <p>From the above output, you can learn the basic syntax of a pipeline, which is a sequence of stages. Usually the stages are separated by <code>--</code> characters; otherwise, <code>bgpipe</code> will try to separate the stages automatically, although this can lead to ambiguities for more complex pipelines. Global <code>bgpipe</code> options are specified before the first stage, and options for each stage are specified immediately after the stage name.</p> <p>A stage is a specific processing step in the pipeline, such as connecting to a BGP endpoint, filtering messages, or executing a command. You can think of it as a building block that performs a specific task in the overall message processing flow. For a catalog of stages and their options, see the Stages overview and the per-stage docs. In order to learn more about a specific stage, you can run <code>bgpipe &lt;stage&gt; -h</code>, for example:</p> <pre><code>$ bgpipe connect -h\nStage usage: connect [OPTIONS] ADDR\n\nDescription: connect to a BGP endpoint over TCP\n\nOptions:\n      --bind string               local address to bind to (IP or IP:port)\n      --md5 string                TCP MD5 password\n      --timeout duration          TCP connect timeout (0 means off) (default 15s)\n      --closed-timeout duration   TCP half-closed timeout (0 means off) (default 1s)\n      --keepalive duration        TCP keepalive period (-1 means off) (default 15s)\n      --retry                     retry connection on temporary errors\n      --retry-max int             maximum number of connection retries (0 means unlimited)\n      --tls                       connect over TLS\n      --insecure                  do not validate TLS certificates\n      --no-ipv6                   avoid IPv6 if possible\n\nCommon Options:\n  -L, --left                      operate in the L direction\n  -R, --right                     operate in the R direction\n  -A, --args                      consume all CLI arguments till --\n  -W, --wait strings              wait for given event before starting\n  -S, --stop strings              stop after given event is handled\n  -N, --new string                which stage to send new messages to (default \"next\")\n  -O, --of stringArray            stage output filter (drop non-matching output)\n      --rate-limit float          delay messages if over the rate limit\n      --rate-sample float         sample messages if over the rate limit\n</code></pre> <p>As you can see, the <code>connect</code> stage has its own set of options, such as <code>--timeout</code>, <code>--closed-timeout</code>, and <code>--md5</code>, which are specific to establishing a BGP connection. The common options, such as <code>-L</code>, <code>-R</code>, etc. are available for all stages and control how the stage operates in the pipeline context.</p> <p>By default, all stages operate in the right (<code>-R</code>) direction, meaning that they process BGP messages flowing from left to right. The direction controls which messages to capture for processing in a stage, and where to send new messages. However, if the last stage connects to a BGP endpoint, by default it will operate in the left (<code>-L</code>) direction, meaning it will send new messages to the left of the pipeline. Usually, the left-most and/or right-most stage is the one that connects to a BGP endpoint, while the other stages process messages in between. If you want bidirectional processing, use the <code>-L</code> and <code>-R</code> options together, ie. <code>-LR</code>.</p> <p>For writing BGP message filters used by the <code>grep</code> and <code>drop</code> stages, see the dedicated filter reference with attributes, operators, and examples.</p>"},{"location":"quickstart/#reading-mrt-files","title":"Reading MRT files","text":"<p>Let's demonstrate basic message processing by reading MRT files. MRT files are a standard format for storing BGP messages, and <code>bgpipe</code> can read them from a file or a URL. You can even stream MRT files directly from the RIPE NCC RIS or RouteViews archives.</p> <p>Below is an example of reading a compressed MRT file from the RIPE NCC RIS archive, filtering it for a specific prefix, and printing the results to stdout (see read, grep, and stdout):</p> <pre><code>$ bgpipe \\\n    -- read https://data.ris.ripe.net/rrc01/latest-update.gz \\\n    -- grep 'prefix ~ 8.0.0.0/8' \\\n    -- stdout\n2025-07-04 13:17:47 INF streaming https://data.ris.ripe.net/rrc01/latest-update.gz stage=\"[1] read\"\n[\"R\",6826,\"2025-07-04T13:05:19.000\",\"UPDATE\",{\"reach\":[\"8.20.247.0/24\",\"8.26.56.0/24\",\"104.37.179.0/24\",\"199.167.65.0/24\"],\"attrs\":{\"ORIGIN\":{\"flags\":\"T\",\"value\":\"IGP\"},\"ASPATH\":{\"flags\":\"T\",\"value\":[8218,174,20473,23393]},\"NEXTHOP\":{\"flags\":\"T\",\"value\":\"5.57.80.210\"},\"MED\":{\"flags\":\"O\",\"value\":4},\"COMMUNITY\":{\"flags\":\"OT\",\"value\":[\"8218:102\",\"8218:20000\",\"8218:20110\"]}}},{\"PEER_AS\":\"8218\",\"PEER_IP\":\"5.57.80.210\",\"LOCAL_AS\":\"12654\",\"LOCAL_IP\":\"5.57.80.4\"}]\n[\"R\",7431,\"2025-07-04T13:05:21.000\",\"UPDATE\",{\"reach\":[\"8.20.247.0/24\",\"8.26.56.0/24\",\"104.37.179.0/24\",\"199.167.65.0/24\"],\"attrs\":{\"ORIGIN\":{\"flags\":\"T\",\"value\":\"IGP\"},\"ASPATH\":{\"flags\":\"T\",\"value\":[8218,20473,23393]},\"NEXTHOP\":{\"flags\":\"T\",\"value\":\"5.57.80.210\"},\"MED\":{\"flags\":\"O\",\"value\":4},\"COMMUNITY\":{\"flags\":\"OT\",\"value\":[\"8218:102\",\"8218:20000\",\"8218:20110\"]},\"OTC\":{\"flags\":\"OTP\",\"value\":\"0x00001a79\"}}},{\"LOCAL_AS\":\"12654\",\"LOCAL_IP\":\"5.57.80.4\",\"PEER_AS\":\"8218\",\"PEER_IP\":\"5.57.80.210\"}]\n// ...\n</code></pre> <p>In the above, the <code>read</code> stage streams the latest BGP updates from the <code>rrc01</code> RIPE RIS collector, uncompresses the data on the fly, and sends back to the pipeline for further processing. Next, the <code>grep</code> stage captures these messages, applies a BGP message filter that an IP prefix must overlap with <code>8.0.0.0/8</code>, and sends matching messages to the next stage (non-matching traffic is dropped). Finally, the <code>stdout</code> stage converts the messages to JSON format and prints them to the standard output.</p> <p>Note that <code>bgpipe</code> provides the <code>--explain</code> (short <code>-n</code>) debugging option that prints the pipeline as configured, but without actually running anything. For example:</p> <pre><code>$ bgpipe -n \\\n    -- read https://data.ris.ripe.net/rrc01/latest-update.gz \\\n    -- grep 'prefix ~ 8.0.0.0/8' \\\n    -- stdout\n--&gt; MESSAGES FLOWING RIGHT --&gt;\n  [1] read https://data.ris.ripe.net/rrc01/latest-update.gz\n      writes messages to pipeline inputs=1\n  [2] grep prefix ~ 8.0.0.0/8\n      reads messages from pipeline callbacks=1 types=[ALL]\n  [3] stdout\n      reads messages from pipeline callbacks=1 types=[ALL]\n\n&lt;-- MESSAGES FLOWING LEFT &lt;--\n  (none)\n</code></pre> <p>Last but not least, instead of putting the <code>stdout</code> stage explicitly in the pipeline, you can use the <code>--stdout</code> (short <code>-o</code>) option to <code>bgpipe</code>, in order to print BGP messages to stdout automatically. It will print all messages that make it to the very end of the left-hand side or right-hand side of the pipeline, ie. all messages that are not dropped by any stage.</p> <pre><code>$ bgpipe -o \\\n    -- read https://data.ris.ripe.net/rrc01/latest-update.gz \\\n    -- grep 'prefix ~ 8.0.0.0/8'\n...\n</code></pre>"},{"location":"quickstart/#connecting-to-a-bgp-speaker","title":"Connecting to a BGP speaker","text":"<p>Now that you know how to read MRT files, let's connect to a BGP speaker and process messages in real-time. You can use the connect stage to establish the TCP connection, and the speaker stage to open and maintain a BGP session.</p> <p>We will use this opportunity to connect to one of the BGP projects run by \u0141ukasz Bromirski. The following command connects to the BGP Blackholing with Flowspec endpoint and prints the conversation to stdout, which demonstrates that <code>bgpipe</code> supports Flowspec:</p> <pre><code>$ bgpipe -o \\\n    -- speaker --active --asn 65055 \\\n    -- connect 85.232.240.180\n2025-07-11 10:47:20 INF dialing 85.232.240.180:179 stage=\"[2] connect\"\n2025-07-11 10:47:20 INF connection R_LOCAL = 192.168.200.202:59438 stage=\"[2] connect\"\n2025-07-11 10:47:20 INF connection R_REMOTE = 85.232.240.180:179 stage=\"[2] connect\"\n2025-07-11 10:47:20 INF connected 192.168.200.202:59438 -&gt; 85.232.240.180:179 stage=\"[2] connect\"\n[\"R\",1,\"2025-07-11T08:47:20.650\",\"OPEN\",{\"bgp\":4,\"asn\":65055,\"id\":\"0.0.0.1\",\"hold\":90,\"caps\":{\"MP\":[\"IPV4/UNICAST\",\"IPV4/FLOWSPEC\",\"IPV6/UNICAST\",\"IPV6/FLOWSPEC\"],\"ROUTE_REFRESH\":true,\"EXTENDED_MESSAGE\":true,\"AS4\":65055}},{}]\n[\"L\",1,\"2025-07-11T08:47:22.659\",\"OPEN\",{\"bgp\":4,\"asn\":65055,\"id\":\"85.232.240.180\",\"hold\":7200,\"caps\":{\"MP\":[\"IPV4/FLOWSPEC\"],\"ROUTE_REFRESH\":true,\"EXTENDED_NEXTHOP\":[\"IPV4/UNICAST/IPV6\",\"IPV4/MULTICAST/IPV6\",\"IPV4/MPLS_VPN/IPV6\"],\"AS4\":65055,\"PRE_ROUTE_REFRESH\":true}},{}]\n[\"L\",2,\"2025-07-11T08:47:22.659\",\"KEEPALIVE\",null,{}]\n[\"R\",2,\"2025-07-11T08:47:22.659\",\"KEEPALIVE\",null,{}]\n2025-07-11 10:47:22 INF negotiated session capabilities caps=\"{\\\"MP\\\":[\\\"IPV4/FLOWSPEC\\\"],\\\"ROUTE_REFRESH\\\":true,\\\"AS4\\\":65055}\"\n2025-07-11 10:47:22 INF event bgpfix/pipe.ESTABLISHED evseq=15 vals=[1752223642]\n...\n</code></pre>"},{"location":"quickstart/#proxying-bgp-sessions","title":"Proxying BGP sessions","text":"<p>Let's now see how to use <code>bgpipe</code> to proxy BGP sessions. You can use the listen stage to accept incoming connections on one side, and the connect stage to forward BGP messages to another router on another side. This allows you to create a transparent proxy that can filter, modify, or log BGP messages.</p> <p>For example, let's use the Vultr's BGP feature, where you already have a local BIRD instance, with the following configuration:</p> <pre><code>log syslog all;\nrouter id 1.2.3.4;\n\nprotocol bgp vultr\n{\n  local as 123;\n  source address 1.2.3.4;\n  ipv4 {\n    import none;\n    export none;\n  };\n  graceful restart on;\n  multihop 2;\n  neighbor 169.254.169.254 as 64515;\n  password \"solarwinds123\";\n}\n</code></pre> <p>Let's say you'd like to see all UPDATEs that match a specific ASN <code>15169</code>. First, let's run a <code>bgpipe</code> proxy that listens on port <code>1790</code> and connects to the upstream router with TCP-MD5 when its client connects.</p> <pre><code>$ bgpipe \\\n  -- connect --wait listen --md5 \"solarwinds123\" 169.254.169.254 \\\n  -- stdout -LR --if \"as_path = 15169\" \\\n  -- listen localhost:1790\n2025-07-11 09:16:47 INF listening on 127.0.0.1:1790 stage=\"[3] listen\"\n</code></pre> <p>Now let's reconfigure the BIRD instance to connect to <code>bgpipe</code> instead of the upstream router. Change the <code>neighbor</code> line in the BIRD configuration to point to <code>localhost:1790</code>:</p> <pre><code>// ...\nprotocol bgp vultr\n{\n  // ...\n  neighbor 127.0.0.1 port 1790 as 64515;\n  // password \"\"; // no password needed\n}\n</code></pre> <p>Finally, restart your BIRD instance and you should see <code>bgpipe</code> reporting new connections, followed by JSON representations of BGP messages matching your filter:</p> <pre><code>2025-07-11 11:23:45 INF connection R_LOCAL = 127.0.0.1:1790 stage=\"[3] listen\"\n2025-07-11 11:23:45 INF connection R_REMOTE = 1.2.3.4:36297 stage=\"[3] listen\"\n2025-07-11 11:23:45 INF connected 127.0.0.1:1790 -&gt; 1.2.3.4:36297 stage=\"[3] listen\"\n2025-07-11 11:23:45 INF dialing 169.254.169.254:179 stage=\"[1] connect\"\n2025-07-11 11:23:45 INF connection L_LOCAL = 1.2.3.4:33514 stage=\"[1] connect\"\n2025-07-11 11:23:45 INF connection L_REMOTE = 169.254.169.254:179 stage=\"[1] connect\"\n2025-07-11 11:23:45 INF connected 1.2.3.4:33514 -&gt; 169.254.169.254:179 stage=\"[1] connect\"\n2025-07-11 11:23:46 INF negotiated session capabilities caps=\"{\\\"MP\\\":[\\\"IPV4/UNICAST\\\"],\\\"ROUTE_REFRESH\\\":true,\\\"GRACEFUL_RESTART\\\":true,\\\"AS4\\\":64515,\\\"ENHANCED_ROUTE_REFRESH\\\":true,\\\"LLGR\\\":true}\"\n2025-07-11 11:23:46 INF event bgpfix/pipe.ESTABLISHED evseq=15 vals=[1752233026]\n2025-07-11 11:23:49 INF event bgpfix/pipe.EOR evdir=L evseq=18\n[\"R\",243,\"2025-07-11T11:23:50.860\",\"UPDATE\",{\"reach\":[...],\"attrs\":{\"ORIGIN\":{\"flags\":\"T\",\"value\":\"EGP\"},\"ASPATH\":{\"flags\":\"TX\",\"value\":[64515,65534,20473,15169,396982]},\"NEXTHOP\":{\"flags\":\"T\",\"value\":\"169.254.169.254\"},\"COMMUNITY\":{\"flags\":\"OT\",\"value\":[\"20473:300\",\"20473:15169\",\"64515:44\"]},\"LARGE_COMMUNITY\":{\"flags\":\"OT\",\"value\":[\"20473:300:15169\"]}}},{}]\n...\n</code></pre>"},{"location":"quickstart/#filtering-with-python-scripts","title":"Filtering with Python scripts","text":"<p>The exec stage lets you process BGP messages with external scripts. <code>bgpipe</code> sends JSON arrays (see JSON format docs) to the script's stdin and reads modified/filtered messages from stdout. This makes it easy to implement custom BGP logic in any language.</p> <p>Here's a simple Python script that only allows IPv4 prefixes shorter than <code>/16</code>:</p> <pre><code>#!/usr/bin/env python3\n\nimport sys\nimport json\n\nfor line in sys.stdin:\n    msg = json.loads(line)\n    if msg[3] == \"UPDATE\":\n        if \"reach\" in msg[4]: \n            msg[4][\"reach\"] = [p for p in msg[4][\"reach\"] if int(p.split(\"/\")[1]) &lt; 16]\n            if len(msg[4][\"reach\"]) &gt; 0 :\n                print(json.dumps(msg), flush=True)\n</code></pre> <p>Use it in a pipeline, stop after printing the first 10 messages:</p> <pre><code>chmod +x ./drop-long-prefixes.py\nbgpipe -o \\\n  -- read https://data.ris.ripe.net/rrc01/latest-update.gz \\\n  -- exec ./drop-long-prefixes.py \\\n| head\n</code></pre> <p>The script receives each message as a JSON array <code>[dir, seq, time, type, data, meta]</code>, processes it, and forwards it downstream. You can modify messages, drop them (by not printing), or generate new ones. For bidirectional processing, remember to use the <code>-LR</code> flags on the <code>exec</code> stage.</p>"},{"location":"quickstart/#conclusion","title":"Conclusion","text":"<p>For more practical pipelines and advanced use cases, check out the examples page. It contains real-world bgpipe command lines for BGP monitoring, proxying, filtering, and more.</p> <p>Happy bgpiping!</p>"},{"location":"stages/","title":"Stages","text":"<p>A stage is a processing step in a bgpipe pipeline. Each stage performs a specific task: connecting to a BGP speaker, filtering messages, writing to a file, and so on. Stages are composed left-to-right on the command line, separated by <code>--</code>.</p> <pre><code>bgpipe [OPTIONS] [--] STAGE1 [OPTIONS] [ARGS] [--] STAGE2 [OPTIONS] [ARGS] ...\n</code></pre>"},{"location":"stages/#available-stages","title":"Available Stages","text":"Stage Description connect Connect to a BGP endpoint over TCP drop Drop messages matching a filter; keep the rest exec Pipe messages through an external process grep Keep messages matching a filter; drop the rest head Stop the pipeline after N messages limit Enforce prefix length and count limits listen Accept an incoming BGP connection over TCP pipe Exchange messages through a named pipe (FIFO) read Read messages from a file or URL ris-live Stream BGP updates from RIPE RIS Live rpki Validate UPDATE messages using RPKI rv-live Stream BGP updates from RouteViews via Kafka speaker Run a simple BGP speaker stdin Read messages from standard input stdout Write messages to standard output tag Add or remove message tags update Modify UPDATE message attributes websocket Exchange messages over WebSocket write Write messages to a file"},{"location":"stages/#common-options","title":"Common Options","text":"<p>Every stage accepts the following options:</p> Option Description <code>-L</code>, <code>--left</code> Operate in the L (left) direction <code>-R</code>, <code>--right</code> Operate in the R (right) direction <code>-A</code>, <code>--args</code> Consume all remaining CLI arguments until <code>--</code> <code>-W</code>, <code>--wait</code> events Wait for given event(s) before starting <code>-S</code>, <code>--stop</code> events Stop the stage after given event(s) <code>--rate-limit</code> N Delay messages to stay under N messages/sec <code>--rate-sample</code> N Randomly sample messages when over N messages/sec <p>Stages that produce messages also accept:</p> Option Description <code>-N</code>, <code>--new</code> target Which stage to send new messages to (default <code>next</code>) <p>In <code>--wait</code> and <code>--stop</code>, multiple events can be comma-separated. If you refer a stage name (e.g., <code>listen</code>), the event is expanded by appending <code>/READY</code> (e.g., <code>listen/READY</code>), which is emitted when the stage is ready to process messages (e.g., after accepting a new connection). You can also refer to custom events emitted by stages (e.g., <code>grep/match</code>).</p> <p>Stages that support input or output filtering:</p> Option Description <code>-I</code>, <code>--if</code> filters Input filter: skip capturing messages that don't match all the filters <code>-O</code>, <code>--of</code> filters Output filter: drop produced messages that don't match all the filters"},{"location":"stages/#direction","title":"Direction","text":"<p>By default, stages operate in the right (<code>-R</code>) direction, processing messages flowing left-to-right. The last stage that connects to a BGP endpoint defaults to the left (<code>-L</code>) direction instead. Use <code>-LR</code> for bidirectional processing.</p>"},{"location":"stages/#see-also","title":"See Also","text":"<p>Quick Start, Examples, Message Filters, JSON Format</p>"},{"location":"stages/connect/","title":"connect","text":"<p>Connect to a BGP endpoint over TCP.</p>"},{"location":"stages/connect/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- connect [OPTIONS] ADDR\n</code></pre>"},{"location":"stages/connect/#description","title":"Description","text":"<p>The connect stage establishes a TCP connection to a remote BGP speaker at ADDR. It is both a producer and a consumer: it reads BGP messages from the wire and writes pipeline messages to the remote peer.</p> <p>The ADDR argument specifies the target as <code>host</code>, <code>host:port</code>, or <code>[host]:port</code>. If no port is given, the default BGP port 179 is used.</p> <p>By default, connect messages flow left-to-right (<code>-R</code> direction), but if it is the last stage in the pipeline, it defaults to the left (<code>-L</code>) direction, so that incoming messages from the remote peer flow right-to-left through the pipeline.</p> <p>As a shorthand, a bare IP address can be used as a stage name instead of writing <code>connect</code> explicitly:</p> <pre><code>bgpipe -o speaker -- 1.2.3.4\n# equivalent to:\nbgpipe -o speaker -- connect 1.2.3.4\n</code></pre>"},{"location":"stages/connect/#options","title":"Options","text":"Option Type Default Description <code>--timeout</code> duration <code>15s</code> TCP connect timeout; 0 disables <code>--closed-timeout</code> duration <code>1s</code> TCP half-closed timeout; 0 disables <code>--keepalive</code> duration <code>15s</code> TCP keepalive period; -1 disables <code>--md5</code> string TCP MD5 password (RFC 2385) <code>--bind</code> string Local address to bind to (<code>IP</code> or <code>IP:port</code>) <code>--tls</code> bool <code>false</code> Connect over TLS <code>--insecure</code> bool <code>false</code> Skip TLS certificate validation <code>--no-ipv6</code> bool <code>false</code> Avoid IPv6 when resolving ADDR <code>--retry</code> bool <code>false</code> Retry on temporary connection errors <code>--retry-max</code> int <code>0</code> Max retry attempts; 0 means unlimited"},{"location":"stages/connect/#examples","title":"Examples","text":"<p>Connect to a BGP speaker and dump the session as JSON:</p> <pre><code>bgpipe -o -- speaker --active --asn 65001 -- connect 192.0.2.1\n</code></pre> <p>Connect with TCP-MD5 authentication:</p> <pre><code>bgpipe -o -- speaker -- connect --md5 \"s3cret\" 192.0.2.1\n</code></pre> <p>Connect over TLS with retry:</p> <pre><code>bgpipe -o -- speaker -- connect --tls --retry 192.0.2.1:1179\n</code></pre> <p>Bind to a specific local address (multi-homed host):</p> <pre><code>bgpipe -- connect --bind 10.0.0.1 192.0.2.1 -- listen :179\n</code></pre>"},{"location":"stages/connect/#see-also","title":"See Also","text":"<p>listen, speaker, Stages overview</p>"},{"location":"stages/exec/","title":"exec","text":"<p>Pipe messages through an external process.</p>"},{"location":"stages/exec/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- exec [OPTIONS] COMMAND\nbgpipe [...] -- exec -A COMMAND [ARGS...] --\n</code></pre>"},{"location":"stages/exec/#description","title":"Description","text":"<p>The exec stage runs an external command and exchanges BGP messages with it over stdin/stdout. Pipeline messages are serialized (JSON by default) and sent to the command's stdin; the command's stdout is parsed back into messages and injected into the pipeline.</p> <p>This makes it straightforward to process BGP data with any language - Python, Perl, shell scripts, or compiled programs. The external process receives one message per line and can:</p> <ul> <li>Filter: print only messages it wants to keep</li> <li>Modify: alter message contents and print the result</li> <li>Generate: produce new messages on stdout</li> <li>Drop: simply not print a message to discard it</li> </ul> <p>The command's stderr is forwarded to the bgpipe log.</p> <p>The stage is both a producer and a consumer, and supports bidirectional operation with <code>-LR</code>.</p> <p>Use the <code>-A</code> / <code>--args</code> flag to pass arguments to the command. Without <code>-A</code>, only the first argument after <code>exec</code> is treated as the command path. With <code>-A</code>, all arguments up to the next <code>--</code> are passed to the command.</p>"},{"location":"stages/exec/#options","title":"Options","text":"Option Type Default Description <code>--keep-stdin</code> bool <code>false</code> Keep running if the command's stdin is closed <code>--keep-stdout</code> bool <code>false</code> Keep running if the command's stdout is closed <code>--format</code> string <code>json</code> Data format: <code>json</code>, <code>raw</code>, <code>mrt</code>, <code>exa</code>, <code>bmp</code>, or <code>obmp</code> <code>--type</code> strings Process only messages of given type(s) <code>--skip</code> strings Skip messages of given type(s) <code>--read</code> bool <code>false</code> Read-only mode (don't send pipeline output to command) <code>--write</code> bool <code>false</code> Write-only mode (don't read command output) <code>--copy</code> bool <code>false</code> Mirror messages instead of consuming them <code>--pardon</code> bool <code>false</code> Ignore input parsing errors <code>--no-seq</code> bool <code>false</code> Overwrite input sequence numbers <code>--no-time</code> bool <code>false</code> Overwrite input timestamps <code>--no-tags</code> bool <code>false</code> Drop input message tags"},{"location":"stages/exec/#examples","title":"Examples","text":"<p>Filter updates with a Python script:</p> <pre><code>bgpipe -o -- read updates.mrt.gz -- exec -A python3 filter.py --\n</code></pre> <p>Use sed to rewrite ASNs in OPEN messages:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- exec -LR -A sed -ure '/\"OPEN\"/{ s/65055/65001/g }' -- \\\n    -- connect 10.0.0.1\n</code></pre> <p>Process with ExaBGP-compatible scripts:</p> <pre><code>bgpipe \\\n    -- listen :179 \\\n    -- exec --format exa -LR -A /path/to/script.py -- \\\n    -- connect 192.0.2.1\n</code></pre> <p>Write-only: send messages to a monitoring script without reading back:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- exec --write -LR -A /usr/local/bin/bgp-logger -- \\\n    -- connect 10.0.0.1\n</code></pre>"},{"location":"stages/exec/#python-script-example","title":"Python Script Example","text":"<p>A Python script that filters IPv4 prefixes shorter than /16:</p> <pre><code>#!/usr/bin/env python3\nimport sys, json\n\nfor line in sys.stdin:\n    msg = json.loads(line)\n    if msg[3] == \"UPDATE\":\n        if \"reach\" in msg[4]:\n            msg[4][\"reach\"] = [\n                p for p in msg[4][\"reach\"]\n                if int(p.split(\"/\")[1]) &lt; 16\n            ]\n            if not msg[4][\"reach\"]:\n                continue\n    print(json.dumps(msg), flush=True)\n</code></pre>"},{"location":"stages/exec/#see-also","title":"See Also","text":"<p>pipe, websocket, JSON Format, Stages overview</p>"},{"location":"stages/grep/","title":"grep / drop","text":"<p>Filter messages by matching against a BGP filter expression.</p>"},{"location":"stages/grep/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- grep [OPTIONS] FILTER\nbgpipe [...] -- drop [OPTIONS] FILTER\n</code></pre>"},{"location":"stages/grep/#description","title":"Description","text":"<p>The grep stage keeps messages that match FILTER and drops the rest. The drop stage does the inverse: it drops matching messages and keeps the rest. Both are the same stage with opposite default behavior.</p> <p>The FILTER argument is a BGP filter expression that tests message attributes such as prefix, AS path, communities, and tags. See the Message Filters reference for complete syntax.</p> <p>This stage supports bidirectional operation with <code>-LR</code>. Without <code>-LR</code>, it processes only messages in the stage direction. It matches UPDATE messages by default; non-UPDATE messages (OPEN, KEEPALIVE, NOTIFICATION) are dropped unless explicitly allowed.</p> <p>With <code>--keep</code>, the stage evaluates the filter but never drops messages. This requires at least one of <code>--event-match</code> or <code>--event-fail</code> so that the filter evaluation has a visible effect.</p> <p>As an alternative to a separate grep stage, most consumer stages support the <code>--if</code> flag, which skips the stage for messages that don't match the filter. For example, <code>stdout --if 'ipv6'</code> prints only IPv6 updates.</p>"},{"location":"stages/grep/#options","title":"Options","text":"Option Type Default Description <code>--keep</code> bool <code>false</code> Evaluate the filter but never drop (requires <code>--event-*</code>) <code>--event-match</code> string Emit this event when a message matches <code>--event-fail</code> string Emit this event when a message does not match <code>--kill-match</code> bool <code>false</code> Kill the process on filter match <code>--kill-fail</code> bool <code>false</code> Kill the process on filter failure"},{"location":"stages/grep/#examples","title":"Examples","text":"<p>Keep only IPv6 updates:</p> <pre><code>bgpipe -o -- read updates.mrt.gz -- grep 'ipv6'\n</code></pre> <p>Drop updates with AS path containing AS64512:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- drop 'as_path ~ ,64512,' \\\n    -- connect 10.0.0.1\n</code></pre> <p>Filter updates by origin AS and prefix:</p> <pre><code>bgpipe -o -- read updates.mrt.gz -- grep 'as_origin == 15169 &amp;&amp; prefix ~ 8.8.0.0/16'\n</code></pre> <p>Emit an event on match without dropping:</p> <pre><code>bgpipe --events grep/hijack \\\n    -- connect 192.0.2.1 \\\n    -- grep --keep --event-match hijack 'prefix ~ 192.0.2.0/24 &amp;&amp; as_origin != 64496' \\\n    -- connect 10.0.0.1\n</code></pre> <p>Kill the session if a default route is announced:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- grep --kill-match default 'prefix == 0.0.0.0/0' \\\n    -- connect 10.0.0.1\n</code></pre> <p>Use <code>--if</code> on a stage instead of a separate grep:</p> <pre><code>bgpipe -o -- read updates.mrt.gz -- stdout --if 'as_origin == 15169'\n</code></pre>"},{"location":"stages/grep/#see-also","title":"See Also","text":"<p>Message Filters, tag, limit, Stages overview</p>"},{"location":"stages/head/","title":"head","text":"<p>Stop the pipeline after a fixed number of messages.</p>"},{"location":"stages/head/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- head [OPTIONS]\n</code></pre>"},{"location":"stages/head/#description","title":"Description","text":"<p>The head stage lets only the first N messages pass and then stops the pipeline. This is useful for sampling or quick tests against a live source.</p> <p>The message count is taken from messages seen in the stage direction (or both when using <code>-LR</code>). When the limit is reached, the stage passes that message and stops the pipeline.</p>"},{"location":"stages/head/#options","title":"Options","text":"Option Type Default Description <code>-n</code>, <code>--count</code> int <code>10</code> Number of messages to pass before stopping"},{"location":"stages/head/#examples","title":"Examples","text":"<p>Stop after 20 updates from a live session:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- head -n 20 \\\n    -- stdout\n</code></pre> <p>Sample 100 messages in both directions:</p> <pre><code>bgpipe \\\n    -- listen :179 \\\n    -- head -LR -n 100 \\\n    -- connect 192.0.2.1\n</code></pre>"},{"location":"stages/head/#see-also","title":"See Also","text":"<p>grep, limit, Stages overview</p>"},{"location":"stages/limit/","title":"limit","text":"<p>Enforce prefix length and count limits.</p>"},{"location":"stages/limit/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- limit [OPTIONS]\n</code></pre>"},{"location":"stages/limit/#description","title":"Description","text":"<p>The limit stage enforces constraints on BGP UPDATE messages to prevent prefix flooding attacks (such as the Kirin attack). It tracks announced prefixes and drops messages that violate configured limits.</p> <p>The stage supports three types of count limits:</p> <ul> <li>Session limit (<code>--session</code>): maximum total prefixes across the session</li> <li>Origin limit (<code>--origin</code>): maximum prefixes per origin AS</li> <li>Block limit (<code>--block</code>): maximum prefixes per IP address block</li> </ul> <p>Prefix length limits (<code>--min-length</code>, <code>--max-length</code>) reject individual prefixes that are too specific or too broad.</p> <p>Use <code>--ipv4</code> and/or <code>--ipv6</code> to select which address families to process. If neither is specified, only IPv4 is processed. Use separate limit stages for different limits on IPv4 and IPv6.</p> <p>The stage tracks prefix state across the session lifetime, correctly handling both announcements and withdrawals (unless <code>--permanent</code> is set).</p> <p>This stage supports bidirectional operation with <code>-LR</code>, aggregating counts from both directions. Without <code>-LR</code>, it tracks only the stage direction.</p>"},{"location":"stages/limit/#options","title":"Options","text":"Option Type Default Description <code>-4</code>, <code>--ipv4</code> bool <code>false</code> Process IPv4 prefixes (default if neither -4 nor -6 given) <code>-6</code>, <code>--ipv6</code> bool <code>false</code> Process IPv6 prefixes <code>--multicast</code> bool <code>false</code> Include multicast address families <code>--permanent</code> bool <code>false</code> Ignore withdrawals (announcements are permanent) <code>-m</code>, <code>--min-length</code> int <code>0</code> Minimum prefix length; 0 disables <code>-M</code>, <code>--max-length</code> int <code>0</code> Maximum prefix length; 0 disables <code>-s</code>, <code>--session</code> int <code>0</code> Global session prefix limit; 0 disables <code>-o</code>, <code>--origin</code> int <code>0</code> Per-AS origin prefix limit; 0 disables <code>-b</code>, <code>--block</code> int <code>0</code> Per-IP-block prefix limit; 0 disables <code>-B</code>, <code>--block-length</code> int <code>0</code> IP block prefix length (max 64); 0 means /16 (IPv4) or /32 (IPv6)"},{"location":"stages/limit/#events","title":"Events","text":"<p>The stage emits events prefixed with <code>limit/</code> when limits are violated:</p> Event Trigger <code>limit/short</code> Prefix shorter than <code>--min-length</code> <code>limit/long</code> Prefix exceeds <code>--max-length</code> <code>limit/session</code> Session prefix count exceeds <code>--session</code> <code>limit/origin</code> Per-origin prefix count exceeds <code>--origin</code> <code>limit/block</code> Per-block prefix count exceeds <code>--block</code> <p>Use <code>--events limit/session</code> on bgpipe to log these events, or <code>--kill limit/session</code> to terminate the session when a limit is hit.</p>"},{"location":"stages/limit/#examples","title":"Examples","text":"<p>Enforce standard prefix length limits for IPv4 and IPv6:</p> <pre><code>bgpipe --kill limit/session \\\n    -- connect 192.0.2.1 \\\n    -- limit -LR -4 --min-length 8 --max-length 24 --session 1000000 \\\n    -- limit -LR -6 --min-length 16 --max-length 48 --session 250000 \\\n    -- connect 10.0.0.1\n</code></pre> <p>Limit per-origin AS prefix count (detect prefix hijack floods):</p> <pre><code>bgpipe --events limit/origin \\\n    -- connect 192.0.2.1 \\\n    -- limit -LR --origin 5000 \\\n    -- connect 10.0.0.1\n</code></pre> <p>Limit per /16 block (IPv4) to detect concentrated floods:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- limit --block 10000 --block-length 16 \\\n    -- connect 10.0.0.1\n</code></pre>"},{"location":"stages/limit/#see-also","title":"See Also","text":"<p>grep, rpki, Kirin Attack, Stages overview</p>"},{"location":"stages/listen/","title":"listen","text":"<p>Accept an incoming BGP connection over TCP.</p>"},{"location":"stages/listen/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- listen [OPTIONS] [ADDR]\n</code></pre>"},{"location":"stages/listen/#description","title":"Description","text":"<p>The listen stage binds to a local TCP address and waits for a single incoming BGP connection. It is both a producer and a consumer: it reads BGP messages from the connected client and writes pipeline messages back to it.</p> <p>The optional ADDR argument specifies the listen address as <code>host:port</code>, <code>:port</code>, or <code>host</code>. Defaults to <code>:179</code> (all interfaces, standard BGP port).</p> <p>Once a client connects, the listener closes and no further connections are accepted.</p> <p>By default, listen messages flow left-to-right (<code>-R</code> direction), but if it is the last stage in the pipeline, it defaults to the left (<code>-L</code>) direction, so that incoming messages flow right-to-left.</p>"},{"location":"stages/listen/#options","title":"Options","text":"Option Type Default Description <code>--timeout</code> duration <code>0</code> Accept timeout; 0 means wait indefinitely <code>--closed-timeout</code> duration <code>1s</code> TCP half-closed timeout; 0 disables <code>--keepalive</code> duration <code>15s</code> TCP keepalive period; -1 disables <code>--md5</code> string TCP MD5 password (Linux only)"},{"location":"stages/listen/#examples","title":"Examples","text":"<p>Listen on the default BGP port and proxy to an upstream router:</p> <pre><code>bgpipe -- connect --wait listen 192.0.2.1 -- listen :179\n</code></pre> <p>Listen on a non-standard port for local BIRD integration:</p> <pre><code>bgpipe -- connect --wait listen --md5 \"s3cret\" 192.0.2.1 -- listen localhost:1790\n</code></pre> <p>Add TCP-MD5 to a session (listen without, connect with):</p> <pre><code>bgpipe -o -- listen :179 -- connect --md5 \"s3cret\" 10.0.0.1\n</code></pre>"},{"location":"stages/listen/#see-also","title":"See Also","text":"<p>connect, speaker, Stages overview</p>"},{"location":"stages/pipe/","title":"pipe","text":"<p>Exchange messages through a named pipe (FIFO).</p>"},{"location":"stages/pipe/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- pipe [OPTIONS] PATH\n</code></pre>"},{"location":"stages/pipe/#description","title":"Description","text":"<p>The pipe stage reads and writes BGP messages through a named pipe (FIFO). It is both a producer and a consumer, and supports bidirectional operation with <code>-LR</code>.</p> <p>The PATH argument specifies the path to a named pipe created with <code>mkfifo(1)</code>. The stage opens the pipe for both reading and writing simultaneously.</p> <p>Messages are exchanged in JSON format by default (one per line).</p>"},{"location":"stages/pipe/#options","title":"Options","text":"Option Type Default Description <code>--format</code> string <code>json</code> Data format: <code>json</code>, <code>raw</code>, <code>mrt</code>, <code>exa</code>, <code>bmp</code>, or <code>obmp</code> <code>--type</code> strings Process only messages of given type(s) <code>--skip</code> strings Skip messages of given type(s) <code>--read</code> bool <code>false</code> Read-only mode <code>--write</code> bool <code>false</code> Write-only mode <code>--copy</code> bool <code>false</code> Mirror messages instead of consuming them <code>--pardon</code> bool <code>false</code> Ignore input parsing errors <code>--no-seq</code> bool <code>false</code> Overwrite input sequence numbers <code>--no-time</code> bool <code>false</code> Overwrite input timestamps <code>--no-tags</code> bool <code>false</code> Drop input message tags"},{"location":"stages/pipe/#examples","title":"Examples","text":"<p>Process messages through a named pipe:</p> <pre><code>mkfifo /tmp/bgp-pipe\nbgpipe \\\n    -- connect 192.0.2.1 \\\n    -- pipe -LR /tmp/bgp-pipe \\\n    -- connect 10.0.0.1\n</code></pre> <p>Write-only: send messages to a pipe for external monitoring:</p> <pre><code>mkfifo /tmp/bgp-monitor\nbgpipe \\\n    -- connect 192.0.2.1 \\\n    -- pipe --write -LR /tmp/bgp-monitor \\\n    -- connect 10.0.0.1\n</code></pre>"},{"location":"stages/pipe/#see-also","title":"See Also","text":"<p>exec, websocket, Stages overview</p>"},{"location":"stages/read/","title":"read","text":"<p>Read messages from a file or URL.</p>"},{"location":"stages/read/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- read [OPTIONS] PATH\n</code></pre>"},{"location":"stages/read/#description","title":"Description","text":"<p>The read stage reads BGP messages from a local file or a remote HTTP/HTTPS URL and injects them into the pipeline. It supports bidirectional operation with <code>-LR</code> and uses the data to set each message direction. Without <code>-LR</code>, messages are injected in the stage direction.</p> <p>The input format is auto-detected by default. Detection first tries the file extension (e.g., <code>.mrt</code> or <code>.json</code>), then falls back to sampling the file contents. Supported formats include JSON (one message per line), MRT (BGP4MP), raw BGP wire format, ExaBGP line format, BMP (BGP Monitoring Protocol), and OpenBMP.</p> <p>Compressed files are decompressed automatically when <code>--decompress</code> is set to <code>auto</code> (the default). The compression format is detected from the file extension: <code>.gz</code> (gzip), <code>.bz2</code> (bzip2), <code>.zst</code> / <code>.zstd</code> (Zstandard).</p> <p>For remote URLs, the stage streams data directly without downloading the entire file first, making it suitable for large MRT archives.</p>"},{"location":"stages/read/#options","title":"Options","text":"Option Type Default Description <code>--decompress</code> string <code>auto</code> Decompression: <code>auto</code>, <code>gz</code>, <code>bzip2</code>, <code>zstd</code>, or <code>none</code> <code>--format</code> string <code>auto</code> Data format: <code>json</code>, <code>raw</code>, <code>mrt</code>, <code>exa</code>, <code>bmp</code>, <code>obmp</code>, or <code>auto</code> <code>--type</code> strings Process only messages of given type(s) <code>--skip</code> strings Skip messages of given type(s) <code>--pardon</code> bool <code>false</code> Ignore input parsing errors <code>--no-seq</code> bool <code>false</code> Overwrite input sequence numbers <code>--no-time</code> bool <code>false</code> Overwrite input timestamps <code>--no-tags</code> bool <code>false</code> Drop input message tags"},{"location":"stages/read/#examples","title":"Examples","text":"<p>Read a compressed MRT file from the RIPE RIS archive:</p> <pre><code>bgpipe -o -- read https://data.ris.ripe.net/rrc01/latest-update.gz\n</code></pre> <p>Read a local MRT file and filter for a prefix:</p> <pre><code>bgpipe -o -- read updates.20240301.0000.bz2 -- grep 'prefix ~ 8.0.0.0/8'\n</code></pre> <p>Convert MRT to JSON:</p> <pre><code>bgpipe -- read updates.mrt.gz -- write output.json\n</code></pre> <p>Replay an MRT file into a live BGP session after establishment:</p> <pre><code>bgpipe \\\n    -- speaker --active --asn 65001 \\\n    -- read --wait ESTABLISHED updates.mrt.zst \\\n    -- listen :179\n</code></pre>"},{"location":"stages/read/#see-also","title":"See Also","text":"<p>write, stdin, Stages overview</p>"},{"location":"stages/ris-live/","title":"ris-live","text":"<p>Stream BGP updates from RIPE RIS Live.</p>"},{"location":"stages/ris-live/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- ris-live [OPTIONS]\n</code></pre>"},{"location":"stages/ris-live/#description","title":"Description","text":"<p>The ris-live stage connects to the RIPE NCC RIS Live streaming service and injects real-time BGP updates into the pipeline. RIS Live aggregates BGP data from RIPE RIS route collectors worldwide, providing a global view of Internet routing without requiring your own BGP peering sessions.</p> <p>The stage connects via Server-Sent Events (SSE) to the RIS Live endpoint, extracts raw BGP messages from the stream, and injects them into the pipeline. Each message is tagged with peer and collector metadata:</p> Tag Description <code>PEER_IP</code> IP address of the BGP peer <code>PEER_AS</code> AS number of the BGP peer <code>RIS_ID</code> RIS collector peer ID <code>RIS_HOST</code> RIS collector hostname (e.g., <code>rrc01.ris.ripe.net</code>) <code>COLLECTOR</code> Short collector name derived from RIS_HOST (e.g., <code>rrc01</code>) <p>These tags can be used in downstream filters, for example: <code>tag[PEER_AS] == 13335</code> or <code>tag[RIS_HOST] ~ \"rrc01\"</code>.</p> <p>Connection retries are enabled by default. The stage monitors message freshness and treats stale messages (older than <code>--delay-err</code>) as connection errors, triggering a reconnect.</p> <p>Use <code>--sub</code> to pass a RIS Live subscription filter to limit the data at the source. The subscription JSON should include <code>\"includeRaw\": true</code> (or will be added automatically).</p> <p>The global <code>-g</code> / <code>--guess-asn</code> flag is recommended when using this stage, as different RIS peers may use 2-byte or 4-byte ASNs.</p>"},{"location":"stages/ris-live/#options","title":"Options","text":"Option Type Default Description <code>--url</code> string (RIS Live endpoint) Override the streaming endpoint URL <code>--sub</code> string RIS Subscribe JSON filter <code>--timeout</code> duration <code>10s</code> Connect timeout; 0 disables <code>--read-timeout</code> duration <code>10s</code> Max time between messages before reconnecting <code>--retry</code> bool <code>true</code> Retry connection on errors <code>--retry-max</code> int <code>0</code> Max retry attempts; 0 means unlimited <code>--delay-err</code> duration <code>3m</code> Treat messages older than this as errors; 0 disables"},{"location":"stages/ris-live/#examples","title":"Examples","text":"<p>Stream all RIS Live updates and print to stdout:</p> <pre><code>bgpipe -go -- ris-live\n</code></pre> <p>Monitor a specific prefix in real-time:</p> <pre><code>bgpipe -go -- ris-live -- grep 'prefix ~ 1.1.1.0/24'\n</code></pre> <p>Subscribe to a specific collector:</p> <pre><code>bgpipe -go -- ris-live --sub '{\"host\":\"rrc01\"}'\n</code></pre> <p>Stream with RPKI validation, show only invalid:</p> <pre><code>bgpipe -go \\\n    -- ris-live \\\n    -- rpki --invalid keep \\\n    -- grep 'tag[rpki/status] == INVALID'\n</code></pre> <p>Archive RIS Live to compressed files with hourly rotation:</p> <pre><code>bgpipe -g \\\n    -- ris-live \\\n    -- write --every 1h 'ris-live.$TIME.mrt.gz'\n</code></pre>"},{"location":"stages/ris-live/#see-also","title":"See Also","text":"<p>rv-live, read, RIPE RIS Live, Stages overview</p>"},{"location":"stages/rpki/","title":"rpki","text":"<p>Validate UPDATE messages using RPKI.</p>"},{"location":"stages/rpki/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- rpki [OPTIONS]\n</code></pre>"},{"location":"stages/rpki/#description","title":"Description","text":"<p>The rpki stage validates BGP UPDATE messages against RPKI (Resource Public Key Infrastructure) data. It checks whether the origin AS is authorized to announce each prefix, based on ROA (Route Origin Authorization) records.</p> <p>Each prefix in an UPDATE is assigned one of three RPKI validation states:</p> <ul> <li>VALID - a ROA exists and matches the origin AS and prefix length</li> <li>INVALID - a ROA exists but the origin AS or prefix length does not match</li> <li>NOT_FOUND - no ROA covers this prefix</li> </ul> <p>The stage obtains ROA data either from an RTR (RPKI-to-Router) server or from a local ROA file. By default, it connects to Cloudflare's public RTR server at <code>rtr.rpki.cloudflare.com:8282</code>.</p> <p>The <code>--invalid</code> option controls how INVALID prefixes are handled:</p> Action Behavior <code>withdraw</code> Move invalid prefixes to the withdrawn list (RFC 7606) <code>filter</code> Remove invalid prefixes from the reachable list <code>drop</code> Drop the entire UPDATE if any prefix is invalid <code>split</code> Split invalid prefixes into a separate UPDATE that withdraws them <code>keep</code> Keep invalid prefixes unchanged (tag only) <p>When <code>--tag</code> is enabled (the default), the stage adds <code>rpki/status</code> to message tags, which can be used in downstream filters (e.g., <code>tag[rpki/status] == INVALID</code>).</p> <p>With <code>--strict</code>, prefixes with NOT_FOUND status are treated the same as INVALID. This is an aggressive policy that only allows prefixes with explicit RPKI authorization.</p> <p>The stage waits for the ROA cache to be populated before processing messages (unless <code>--asap</code> is set), ensuring no messages are validated against an incomplete cache.</p>"},{"location":"stages/rpki/#options","title":"Options","text":""},{"location":"stages/rpki/#rtr-connection","title":"RTR Connection","text":"Option Type Default Description <code>--rtr</code> string <code>rtr.rpki.cloudflare.com:8282</code> RTR server address (<code>host:port</code>) <code>--rtr-refresh</code> duration <code>1h</code> RTR cache refresh interval <code>--rtr-retry</code> duration <code>10m</code> RTR retry interval on errors <code>--timeout</code> duration <code>15s</code> Connect timeout; 0 disables <code>--retry</code> bool <code>true</code> Retry connection on errors <code>--retry-max</code> int <code>0</code> Max retry attempts; 0 means unlimited <code>--tls</code> bool <code>false</code> Connect to RTR server over TLS <code>--insecure</code> bool <code>false</code> Skip TLS certificate validation <code>--no-ipv6</code> bool <code>false</code> Avoid IPv6 when connecting to RTR server"},{"location":"stages/rpki/#roa-file","title":"ROA File","text":"Option Type Default Description <code>--file</code> string Use a local ROA file instead of RTR (JSON or CSV, auto-reloaded)"},{"location":"stages/rpki/#validation-policy","title":"Validation Policy","text":"Option Type Default Description <code>--invalid</code> string <code>withdraw</code> Action for INVALID prefixes: <code>withdraw</code>, <code>filter</code>, <code>drop</code>, <code>split</code>, <code>keep</code> <code>--strict</code> bool <code>false</code> Treat NOT_FOUND same as INVALID <code>--tag</code> bool <code>true</code> Add <code>rpki/status</code> to message tags <code>--event</code> string Emit this event on RPKI INVALID messages <code>--asap</code> bool <code>false</code> Start validating before ROA cache is ready"},{"location":"stages/rpki/#examples","title":"Examples","text":"<p>Basic RPKI filtering between two routers (default: withdraw invalid):</p> <pre><code>bgpipe \\\n    -- listen :179 \\\n    -- rpki \\\n    -- connect 192.0.2.1\n</code></pre> <p>Keep invalid prefixes but tag them for downstream processing:</p> <pre><code>bgpipe -o \\\n    -- ris-live \\\n    -- rpki --invalid keep \\\n    -- grep 'tag[rpki/status] == INVALID'\n</code></pre> <p>Strict mode: only allow RPKI-VALID prefixes:</p> <pre><code>bgpipe --events rpki/dropped \\\n    -- listen :179 \\\n    -- rpki --strict --invalid drop --event dropped \\\n    -- connect 192.0.2.1\n</code></pre> <p>Use a local ROA file instead of RTR:</p> <pre><code>bgpipe \\\n    -- listen :179 \\\n    -- rpki --file /var/lib/rpki/roas.json --invalid filter \\\n    -- connect 192.0.2.1\n</code></pre> <p>Tag with RPKI status and add a community to invalid routes:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- rpki --invalid keep \\\n    -- update --if 'tag[rpki/status] == INVALID' --add-com 65000:666 \\\n    -- connect 10.0.0.1\n</code></pre> <p>Connect to an RTR server over TLS:</p> <pre><code>bgpipe \\\n    -- listen :179 \\\n    -- rpki --rtr rpki.example.com:8323 --tls \\\n    -- connect 192.0.2.1\n</code></pre>"},{"location":"stages/rpki/#see-also","title":"See Also","text":"<p>limit, grep, update, RFC 6811 - RPKI-Based Origin Validation, Stages overview</p>"},{"location":"stages/rv-live/","title":"rv-live","text":"<p>Stream BGP updates from RouteViews via Kafka.</p>"},{"location":"stages/rv-live/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- rv-live [OPTIONS]\n</code></pre>"},{"location":"stages/rv-live/#description","title":"Description","text":"<p>The rv-live stage consumes real-time BGP updates from the University of Oregon RouteViews project via its public Kafka stream. RouteViews collects BGP data from routers at major Internet exchange points and transit providers worldwide.</p> <p>The stream carries BGP messages in OpenBMP raw format. The stage parses BMP messages, extracts the inner BGP messages, and injects them into the pipeline with peer metadata as tags:</p> Tag Description <code>PEER_IP</code> IP address of the BGP peer <code>PEER_AS</code> AS number of the BGP peer <code>COLLECTOR</code> RouteViews collector name (e.g., <code>linx</code>) <code>ROUTER</code> Router IP address <p>These tags can be used in downstream filters, for example: <code>tag[COLLECTOR] ~ \"linx\"</code> or <code>tag[PEER_AS] == 13335</code>.</p> <p>By default, the stage subscribes to all topics matching the pattern <code>^routeviews\\..+\\.bmp_raw$</code>, which covers all RouteViews collectors. Use <code>--collector</code> to select specific collectors by name prefix, or <code>--topics</code> to supply a custom topic regex.</p> <p>RouteViews injects the collector's own AS into the AS_PATH of each message. By default, this stage strips that first hop. Use <code>--keep-aspath</code> to preserve the original AS_PATH as received from the collector.</p> <p>The <code>--state</code> option enables offset persistence: the stage saves its Kafka consumer position to a file and resumes from the same point on restart. This prevents re-processing messages after a pipeline restart.</p> <p>Connection retries are enabled by default. The stage monitors data freshness and reconnects when no data arrives for <code>--stale</code> duration.</p> <p>The global <code>-g</code> / <code>--guess-asn</code> flag is recommended when using this stage, as different RouteViews peers may use 2-byte or 4-byte ASNs.</p>"},{"location":"stages/rv-live/#options","title":"Options","text":"Option Type Default Description <code>--broker</code> string <code>stream.routeviews.org:9092</code> Kafka broker address <code>--topics</code> string <code>^routeviews\\..+\\.bmp_raw$</code> Topic regex pattern <code>--collector</code> strings Only subscribe to collectors whose name starts with this prefix <code>--collector-not</code> strings Exclude collectors whose name starts with this prefix <code>--group</code> string (auto-generated) Kafka consumer group ID <code>--state</code> string State file for offset persistence <code>--refresh</code> duration <code>5m</code> Topic list refresh interval <code>--timeout</code> duration <code>30s</code> Connection timeout <code>--stale</code> duration <code>3m</code> Reconnect if no data for this long; 0 disables <code>--retry</code> bool <code>true</code> Retry connection on errors <code>--retry-max</code> int <code>0</code> Max retry attempts; 0 means unlimited <code>--keep-aspath</code> bool <code>false</code> Keep the collector AS in AS_PATH"},{"location":"stages/rv-live/#examples","title":"Examples","text":"<p>Stream all RouteViews updates to stdout:</p> <pre><code>bgpipe -go -- rv-live\n</code></pre> <p>Stream from a specific collector:</p> <pre><code>bgpipe -go -- rv-live --collector linx\n</code></pre> <p>Exclude specific collectors:</p> <pre><code>bgpipe -go -- rv-live --collector-not amsix --collector-not decix\n</code></pre> <p>Persist consumer state for resumable processing:</p> <pre><code>bgpipe -go -- rv-live --state /var/lib/bgpipe/rv-live.state\n</code></pre> <p>Archive RouteViews data with RPKI validation:</p> <pre><code>bgpipe -g \\\n    -- rv-live \\\n    -- rpki --invalid keep \\\n    -- write --every 1h 'rv-updates.$TIME.json.gz'\n</code></pre>"},{"location":"stages/rv-live/#see-also","title":"See Also","text":"<p>ris-live, read, RouteViews, Stages overview</p>"},{"location":"stages/speaker/","title":"speaker","text":"<p>Run a simple BGP speaker.</p>"},{"location":"stages/speaker/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- speaker [OPTIONS]\n</code></pre>"},{"location":"stages/speaker/#description","title":"Description","text":"<p>The speaker stage implements BGP session negotiation. It handles OPEN message exchange, KEEPALIVE generation, and hold timer management. Use it when bgpipe needs to participate as a BGP peer rather than passively proxying an existing session.</p> <p>In passive mode (default), the speaker waits for the remote side to send an OPEN message first, then responds with its own OPEN. In active mode (<code>--active</code>), it sends its OPEN immediately.</p> <p>The speaker automatically negotiates BGP capabilities (MP-BGP, 4-byte ASN, Route Refresh, Extended Messages) with the remote peer. When <code>--asn</code> is set to -1, the speaker mirrors the remote peer's ASN. When <code>--id</code> is empty, it derives a router ID from the remote peer's ID.</p> <p>A speaker stage is not needed when bgpipe operates as a transparent proxy between two BGP speakers that negotiate with each other directly.</p>"},{"location":"stages/speaker/#options","title":"Options","text":"Option Type Default Description <code>--active</code> bool <code>false</code> Send the OPEN message first <code>--asn</code> int <code>-1</code> Local ASN; -1 means mirror the remote ASN <code>--id</code> string Router ID; empty means derive from remote <code>--hold</code> int <code>90</code> Hold time in seconds"},{"location":"stages/speaker/#examples","title":"Examples","text":"<p>Connect to a BGP speaker in active mode:</p> <pre><code>bgpipe -o -- speaker --active --asn 65001 -- connect 192.0.2.1\n</code></pre> <p>Passive speaker that mirrors the remote ASN (useful for testing):</p> <pre><code>bgpipe -o -- speaker -- listen :179\n</code></pre> <p>Speaker with explicit identity:</p> <pre><code>bgpipe -o -- speaker --active --asn 64512 --id 10.0.0.1 -- connect 192.0.2.1\n</code></pre> <p>Replay an MRT file into a live BGP session:</p> <pre><code>bgpipe \\\n    -- speaker --active --asn 65001 \\\n    -- read --wait ESTABLISHED updates.mrt.gz \\\n    -- listen :179\n</code></pre>"},{"location":"stages/speaker/#see-also","title":"See Also","text":"<p>connect, listen, Stages overview</p>"},{"location":"stages/stdin/","title":"stdin","text":"<p>Read messages from standard input.</p>"},{"location":"stages/stdin/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- stdin [OPTIONS]\n</code></pre>"},{"location":"stages/stdin/#description","title":"Description","text":"<p>The stdin stage reads BGP messages from standard input and injects them into the pipeline. It is a producer stage that supports bidirectional operation with <code>-LR</code>: in that case, the direction of each message is taken from the input when available (for JSON, the <code>dir</code> field). Otherwise, messages are injected in the stage direction.</p> <p>The default input format is JSON (one message per line). Supported formats also include MRT (BGP4MP), raw BGP wire format, ExaBGP line format, BMP, and OpenBMP - select with <code>--format</code>.</p> <p>As a shorthand, the global <code>-i</code> / <code>--stdin</code> flag adds an implicit stdin stage at the beginning of the pipeline. The <code>-I</code> / <code>--stdin-wait</code> variant waits for <code>EVENT_ESTABLISHED</code> before reading.</p>"},{"location":"stages/stdin/#options","title":"Options","text":"Option Type Default Description <code>--format</code> string <code>json</code> Data format: <code>json</code>, <code>raw</code>, <code>mrt</code>, <code>exa</code>, <code>bmp</code>, or <code>obmp</code> <code>--type</code> strings Process only messages of given type(s) <code>--skip</code> strings Skip messages of given type(s) <code>--pardon</code> bool <code>false</code> Ignore input parsing errors <code>--no-seq</code> bool <code>false</code> Overwrite input sequence numbers <code>--no-time</code> bool <code>false</code> Overwrite input timestamps <code>--no-tags</code> bool <code>false</code> Drop input message tags"},{"location":"stages/stdin/#examples","title":"Examples","text":"<p>Pipe JSON messages into a BGP session:</p> <pre><code>cat messages.json | bgpipe -i -- speaker --active --asn 65001 -- connect 192.0.2.1\n</code></pre> <p>Read MRT from stdin explicitly:</p> <pre><code>cat updates.mrt | bgpipe -- stdin --format mrt -- stdout\n</code></pre>"},{"location":"stages/stdin/#see-also","title":"See Also","text":"<p>stdout, read, Stages overview</p>"},{"location":"stages/stdout/","title":"stdout","text":"<p>Write messages to standard output.</p>"},{"location":"stages/stdout/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- stdout [OPTIONS]\n</code></pre>"},{"location":"stages/stdout/#description","title":"Description","text":"<p>The stdout stage writes BGP messages to standard output. It is a consumer stage that supports bidirectional operation with <code>-LR</code>; without <code>-LR</code>, it prints only messages in the stage direction.</p> <p>The stage always mirrors messages - it never consumes them from the pipeline, so downstream stages still see every message that stdout prints.</p> <p>The default output format is JSON (one message per line). Use <code>--format</code> to select MRT, raw, ExaBGP line, BMP, or OpenBMP format instead.</p> <p>As a shorthand, the global <code>-o</code> / <code>--stdout</code> flag adds an implicit stdout stage at the end of the pipeline. The <code>-O</code> / <code>--stdout-wait</code> variant waits for <code>EVENT_EOR</code> (End of RIB) before printing.</p>"},{"location":"stages/stdout/#options","title":"Options","text":"Option Type Default Description <code>--format</code> string <code>json</code> Data format: <code>json</code>, <code>raw</code>, <code>mrt</code>, <code>exa</code>, <code>bmp</code>, or <code>obmp</code> <code>--type</code> strings Print only messages of given type(s) <code>--skip</code> strings Skip messages of given type(s)"},{"location":"stages/stdout/#examples","title":"Examples","text":"<p>Print all messages as JSON:</p> <pre><code>bgpipe -- read updates.mrt.gz -- stdout\n</code></pre> <p>Print only after the BGP session is established:</p> <pre><code>bgpipe -O -- speaker --active --asn 65001 -- connect 192.0.2.1\n</code></pre> <p>Print in ExaBGP line format:</p> <pre><code>bgpipe -- read updates.mrt.gz -- stdout --format exa\n</code></pre> <p>Print only UPDATE messages:</p> <pre><code>bgpipe -- read updates.mrt.gz -- stdout --type UPDATE\n</code></pre>"},{"location":"stages/stdout/#see-also","title":"See Also","text":"<p>stdin, write, JSON Format, Stages overview</p>"},{"location":"stages/tag/","title":"tag","text":"<p>Add or remove message tags.</p>"},{"location":"stages/tag/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- tag [OPTIONS]\n</code></pre>"},{"location":"stages/tag/#description","title":"Description","text":"<p>The tag stage manipulates key-value pairs (tags) attached to BGP messages as they flow through the pipeline. Tags are metadata that travel with messages but are not part of the BGP wire format. They appear in the <code>meta</code> field of the JSON representation.</p> <p>Tags are useful for:</p> <ul> <li>Annotating messages with pipeline context (e.g., source collector, timestamp)</li> <li>Passing information between stages (e.g., from rpki to grep)</li> <li>Filtering based on custom criteria using <code>tag[key]</code> in filter expressions</li> </ul> <p>This stage supports bidirectional operation with <code>-LR</code>. Without <code>-LR</code>, it applies only to messages in the stage direction.</p>"},{"location":"stages/tag/#options","title":"Options","text":"Option Type Default Description <code>--add</code> strings Add tags in <code>key=value</code> format <code>--drop</code> strings Drop tags by key; use <code>*</code> to drop all tags <code>--src</code> bool <code>false</code> Add a <code>SRC</code> tag with the source stage name"},{"location":"stages/tag/#examples","title":"Examples","text":"<p>Add a tag to all messages:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- tag --add source=upstream1 \\\n    -- write -LR session.json \\\n    -- connect 10.0.0.1\n</code></pre> <p>Strip all tags before writing:</p> <pre><code>bgpipe -- read tagged-data.json -- tag --drop '*' -- write clean.json\n</code></pre> <p>Tag and filter: add environment tag, then filter on it downstream:</p> <pre><code>bgpipe -o \\\n    -- read updates.mrt.gz \\\n    -- tag --add env=prod \\\n    -- grep 'tag[env] == prod'\n</code></pre>"},{"location":"stages/tag/#see-also","title":"See Also","text":"<p>grep, Message Filters, JSON Format, Stages overview</p>"},{"location":"stages/update/","title":"update","text":"<p>Modify UPDATE message attributes.</p>"},{"location":"stages/update/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- update [OPTIONS]\n</code></pre>"},{"location":"stages/update/#description","title":"Description","text":"<p>The update stage modifies BGP UPDATE messages in-flight. It can rewrite next-hop addresses and manipulate community attributes. Non-UPDATE messages pass through unchanged.</p> <p>This stage supports bidirectional operation with <code>-LR</code>. Without <code>-LR</code>, it applies only to messages in the stage direction. Combine with <code>--if</code> to apply modifications only to messages matching a filter.</p>"},{"location":"stages/update/#options","title":"Options","text":""},{"location":"stages/update/#next-hop","title":"Next-hop","text":"Option Type Default Description <code>--nexthop4</code> string Set next-hop for IPv4 prefixes to this address <code>--nexthop6</code> string Set next-hop for IPv6 prefixes to this address <code>--nexthop-self</code> bool <code>false</code> Set next-hop to our own IP address (when available)"},{"location":"stages/update/#communities","title":"Communities","text":"Option Type Default Description <code>--add-com</code> string Add a standard BGP community (<code>ASN:value</code>) <code>--add-com-ext</code> string Add an extended BGP community <code>--add-com-large</code> string Add a large BGP community (<code>G:L1:L2</code>) <code>--drop-com</code> bool <code>false</code> Remove the COMMUNITY attribute entirely <code>--drop-com-ext</code> bool <code>false</code> Remove the EXT_COMMUNITY attribute entirely <code>--drop-com-large</code> bool <code>false</code> Remove the LARGE_COMMUNITY attribute entirely"},{"location":"stages/update/#examples","title":"Examples","text":"<p>Rewrite next-hop for all updates:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- update --nexthop4 10.0.0.1 \\\n    -- connect 10.0.0.1\n</code></pre> <p>Add a community to tag traffic from a specific peer:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- update --add-com 65000:100 \\\n    -- connect 10.0.0.1\n</code></pre> <p>Strip all communities before forwarding:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- update --drop-com --drop-com-ext --drop-com-large \\\n    -- connect 10.0.0.1\n</code></pre> <p>Conditionally modify: add a community only to RPKI-invalid updates:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- rpki --invalid keep \\\n    -- update --if 'tag[rpki/status] == INVALID' --add-com 65000:666 \\\n    -- connect 10.0.0.1\n</code></pre> <p>Set next-hop to self (useful when proxying):</p> <pre><code>bgpipe \\\n    -- listen :179 \\\n    -- update --nexthop-self \\\n    -- connect 192.0.2.1\n</code></pre>"},{"location":"stages/update/#see-also","title":"See Also","text":"<p>grep, rpki, Stages overview</p>"},{"location":"stages/websocket/","title":"websocket","text":"<p>Exchange messages over WebSocket.</p>"},{"location":"stages/websocket/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- websocket [OPTIONS] URL\n</code></pre>"},{"location":"stages/websocket/#description","title":"Description","text":"<p>The websocket stage sends and receives BGP messages over a WebSocket connection. It supports both client mode (connecting to a remote server) and server mode (<code>--listen</code>), with optional TLS encryption and HTTP basic authentication.</p> <p>The URL argument specifies the WebSocket endpoint. Schemes <code>ws://</code> and <code>wss://</code> are used directly; <code>http://</code> and <code>https://</code> are automatically converted to <code>ws://</code> and <code>wss://</code> respectively.</p> <p>In server mode (<code>--listen</code>), the stage accepts multiple concurrent WebSocket clients and broadcasts messages to all connected clients. If a non-critical client disconnects, the stage continues operating. In server mode with <code>wss://</code>, both <code>--cert</code> and <code>--key</code> are required.</p> <p>In client mode (default), the stage connects to a single remote server. Use <code>--retry</code> to automatically reconnect on connection failures.</p> <p>Incoming messages from WebSocket peers are tagged with <code>websocket/remote</code> containing the remote address, which can be used in downstream filters (e.g., <code>tag[websocket/remote] ~ \"10.0.\"</code>).</p> <p>This stage is both a producer and a consumer, and supports bidirectional operation with <code>-LR</code>.</p>"},{"location":"stages/websocket/#options","title":"Options","text":""},{"location":"stages/websocket/#connection","title":"Connection","text":"Option Type Default Description <code>--listen</code> bool <code>false</code> Run as WebSocket server instead of client <code>--timeout</code> duration <code>10s</code> Connect/handshake timeout; 0 disables <code>--retry</code> bool <code>false</code> Retry client connection on errors <code>--retry-max</code> int <code>0</code> Max retry attempts; 0 means unlimited"},{"location":"stages/websocket/#authentication-and-tls","title":"Authentication and TLS","text":"Option Type Default Description <code>--auth</code> string HTTP basic auth; <code>$ENV_VAR</code> or file path containing <code>user:pass</code> <code>--cert</code> string TLS certificate file path (required for <code>wss://</code> server) <code>--key</code> string TLS private key file path (required for <code>wss://</code> server) <code>--insecure</code> bool <code>false</code> Skip TLS certificate validation <code>--header</code> strings Additional HTTP headers (<code>Header:Value</code> format)"},{"location":"stages/websocket/#data-format","title":"Data Format","text":"Option Type Default Description <code>--format</code> string <code>json</code> Data format: <code>json</code>, <code>raw</code>, <code>mrt</code>, <code>exa</code>, <code>bmp</code>, or <code>obmp</code> <code>--type</code> strings Process only messages of given type(s) <code>--skip</code> strings Skip messages of given type(s) <code>--read</code> bool <code>false</code> Read-only mode <code>--write</code> bool <code>false</code> Write-only mode <code>--copy</code> bool <code>false</code> Mirror messages instead of consuming them <code>--pardon</code> bool <code>false</code> Ignore input parsing errors <code>--no-seq</code> bool <code>false</code> Overwrite input sequence numbers <code>--no-time</code> bool <code>false</code> Overwrite input timestamps <code>--no-tags</code> bool <code>false</code> Drop input message tags"},{"location":"stages/websocket/#examples","title":"Examples","text":"<p>Stream a BGP session to a remote archiver (write-only):</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- websocket --write -LR wss://monitor.example.com/bgp \\\n    -- connect 10.0.0.1\n</code></pre> <p>Connect with authentication from an environment variable:</p> <pre><code>export BGP_AUTH=\"user:s3cret\"\nbgpipe \\\n    -- connect 192.0.2.1 \\\n    -- websocket --write -LR --auth '$BGP_AUTH' wss://monitor.example.com/bgp \\\n    -- connect 10.0.0.1\n</code></pre> <p>Run a WebSocket server for remote clients:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- websocket -LR --listen --cert server.crt --key server.key wss://0.0.0.0:8443/bgp \\\n    -- connect 10.0.0.1\n</code></pre> <p>Client with retry (reconnects on disconnection):</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- websocket -LR --retry wss://monitor.example.com/bgp \\\n    -- connect 10.0.0.1\n</code></pre>"},{"location":"stages/websocket/#see-also","title":"See Also","text":"<p>exec, pipe, Stages overview</p>"},{"location":"stages/write/","title":"write","text":"<p>Write messages to a file.</p>"},{"location":"stages/write/#synopsis","title":"Synopsis","text":"<pre><code>bgpipe [...] -- write [OPTIONS] PATH\n</code></pre>"},{"location":"stages/write/#description","title":"Description","text":"<p>The write stage writes BGP messages to a local file. It is a consumer that supports bidirectional operation with <code>-LR</code> and mirrors messages flowing through the pipeline, serializing them to disk without consuming them - downstream stages still see every message.</p> <p>The PATH argument supports time-based placeholders for automatic file rotation:</p> <ul> <li><code>$TIME</code> is replaced with the current time formatted according to <code>--time-format</code></li> <li><code>${format}</code> uses a custom Go time format (e.g., <code>${2006-01-02}</code>)</li> </ul> <p>When <code>--every</code> is set, the stage rotates to a new file at the given interval. The minimum rotation interval is 60 seconds.</p> <p>Files are written atomically: data is first written to a <code>.tmp</code> file, then renamed to the final path on successful completion. Empty files are removed automatically. Parent directories are created as needed.</p> <p>The output format is auto-detected from the file extension by default. For example, <code>output.json</code> selects JSON, <code>output.mrt</code> selects MRT. Compression is also auto-detected: <code>.gz</code> (gzip), <code>.bz2</code> (bzip2), <code>.zst</code> / <code>.zstd</code> (Zstandard).</p>"},{"location":"stages/write/#options","title":"Options","text":"Option Type Default Description <code>--format</code> string <code>auto</code> Data format: <code>json</code>, <code>raw</code>, <code>mrt</code>, <code>exa</code>, <code>bmp</code>, <code>obmp</code>, or <code>auto</code> (detected from extension) <code>--append</code> bool <code>false</code> Append to file if it already exists <code>--create</code> bool <code>false</code> Fail if the file already exists <code>--compress</code> string <code>auto</code> Compression: <code>auto</code>, <code>gz</code>, <code>bzip2</code>, <code>zstd</code>, or <code>none</code> <code>--every</code> duration <code>0</code> Rotate to a new file at this interval (min 60s) <code>--time-format</code> string <code>20060102.1504</code> Go time format for <code>$TIME</code> placeholder <code>--type</code> strings Write only messages of given type(s) <code>--skip</code> strings Skip messages of given type(s)"},{"location":"stages/write/#examples","title":"Examples","text":"<p>Write a BGP session to a JSON file:</p> <pre><code>bgpipe -- connect 192.0.2.1 -- write -LR session.json -- connect 10.0.0.1\n</code></pre> <p>Write compressed MRT with hourly rotation:</p> <pre><code>bgpipe \\\n    -- connect 192.0.2.1 \\\n    -- write -LR --every 1h 'updates.$TIME.mrt.gz' \\\n    -- connect 10.0.0.1\n</code></pre> <p>Archive only UPDATE messages:</p> <pre><code>bgpipe -- read input.mrt.gz -- write --type UPDATE updates.json\n</code></pre> <p>Append to an existing log:</p> <pre><code>bgpipe -- read new-data.mrt.gz -- write --append archive.json\n</code></pre>"},{"location":"stages/write/#see-also","title":"See Also","text":"<p>read, stdout, Stages overview</p>"}]}